{
  "version": 3,
  "sources": ["../../three-fbx-loader/index.js"],
  "sourcesContent": ["/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or to be any version in Binary format.\n *\n * Supports:\n * \tMesh Generation (Positional Data)\n * \tNormal Data (Per Vertex Drawing Instance)\n *  UV Data (Per Vertex Drawing Instance)\n *  Skinning\n *  Animation\n * \t- Separated Animations based on stacks.\n * \t- Skeletal & Non-Skeletal Animations\n *  NURBS (Open, Closed and Periodic forms)\n *\n * Needs Support:\n * \tIndexed Buffers\n * \tPreRotation support.\n */\n\nmodule.exports = function (THREE) {\n\n\t/**\n\t * Generates a loader for loading FBX files from URL and parsing into\n\t * a THREE.Group.\n\t * @param {THREE.LoadingManager} manager - Loading Manager for loader to use.\n\t */\n  THREE.FBXLoader = function (manager) {\n\n    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n\n  };\n\n  Object.assign(THREE.FBXLoader.prototype, {\n\n\t\t/**\n\t\t * Loads an ASCII/Binary FBX file from URL and parses into a THREE.Group.\n\t\t * THREE.Group will have an animations property of AnimationClips\n\t\t * of the different animations exported with the FBX.\n\t\t * @param {string} url - URL of the FBX file.\n\t\t * @param {function(THREE.Group):void} onLoad - Callback for when FBX file is loaded and parsed.\n\t\t * @param {function(ProgressEvent):void} onProgress - Callback fired periodically when file is being retrieved from server.\n\t\t * @param {function(Event):void} onError - Callback fired when error occurs (Currently only with retrieving file, not with parsing errors).\n\t\t */\n    load: function (url, onLoad, onProgress, onError) {\n\n      var self = this;\n\n      var resourceDirectory = url.split(/[\\\\\\/]/);\n      resourceDirectory.pop();\n      resourceDirectory = resourceDirectory.join('/') + '/';\n\n      var loader = new THREE.FileLoader(this.manager);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n\n        try {\n\n          var scene = self.parse(url, buffer, resourceDirectory);\n\n          onLoad(scene);\n\n        } catch (error) {\n\n          window.setTimeout(function () {\n\n            if (onError) onError(error);\n\n            self.manager.itemError(url);\n\n          }, 0);\n\n        }\n\n      }, onProgress, onError);\n\n    },\n\n\t\t/**\n\t\t * Parses an ASCII/Binary FBX file and returns a THREE.Group.\n\t\t * THREE.Group will have an animations property of AnimationClips\n\t\t * of the different animations within the FBX file.\n\t\t * @param {string} url - URL of the FBX file.\n\t\t * @param {ArrayBuffer} FBXBuffer - Contents of FBX file to parse.\n\t\t * @param {string} resourceDirectory - Directory to load external assets (e.g. textures ) from.\n\t\t * @returns {THREE.Group}\n\t\t */\n    parse: function (url, FBXBuffer, resourceDirectory) {\n\n      var self = this;\n      var FBXTree;\n\n      if (isFbxFormatBinary(FBXBuffer)) {\n\n        FBXTree = new BinaryParser().parse(FBXBuffer);\n\n      } else {\n\n        var FBXText = convertArrayBufferToString(FBXBuffer);\n\n        if (!isFbxFormatASCII(FBXText)) {\n\n          self.manager.itemError(url);\n          throw new Error('FBXLoader: Unknown format.');\n\n        }\n\n        if (getFbxVersion(FBXText) < 7000) {\n\n          self.manager.itemError(url);\n          throw new Error('FBXLoader: FBX version not supported for file at ' + url + ', FileVersion: ' + getFbxVersion(FBXText));\n\n        }\n\n        FBXTree = new TextParser().parse(FBXText);\n\n      }\n\n      // console.log( FBXTree );\n\n      var connections = parseConnections(FBXTree);\n      var images = parseImages(FBXTree);\n      var textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n      var materials = parseMaterials(FBXTree, textures, connections);\n      var deformers = parseDeformers(FBXTree, connections);\n      var geometryMap = parseGeometries(FBXTree, connections, deformers);\n      var sceneGraph = parseScene(FBXTree, connections, deformers, geometryMap, materials);\n\n      return sceneGraph;\n\n    }\n\n  });\n\n\t/**\n\t * Parses map of relationships between objects.\n\t * @param {{Connections: { properties: { connections: [number, number, string][]}}}} FBXTree\n\t * @returns {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>}\n\t */\n  function parseConnections(FBXTree) {\n\n\t\t/**\n\t\t * @type {Map<number, { parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>}\n\t\t */\n    var connectionMap = new Map();\n\n    if ('Connections' in FBXTree) {\n\n\t\t\t/**\n\t\t\t * @type {[number, number, string][]}\n\t\t\t */\n      var connectionArray = FBXTree.Connections.properties.connections;\n      for (var connectionArrayIndex = 0, connectionArrayLength = connectionArray.length; connectionArrayIndex < connectionArrayLength; ++connectionArrayIndex) {\n\n        var connection = connectionArray[connectionArrayIndex];\n\n        if (!connectionMap.has(connection[0])) {\n\n          connectionMap.set(connection[0], {\n            parents: [],\n            children: []\n          });\n\n        }\n\n        var parentRelationship = { ID: connection[1], relationship: connection[2] };\n        connectionMap.get(connection[0]).parents.push(parentRelationship);\n\n        if (!connectionMap.has(connection[1])) {\n\n          connectionMap.set(connection[1], {\n            parents: [],\n            children: []\n          });\n\n        }\n\n        var childRelationship = { ID: connection[0], relationship: connection[2] };\n        connectionMap.get(connection[1]).children.push(childRelationship);\n\n      }\n\n    }\n\n    return connectionMap;\n\n  }\n\n\t/**\n\t * Parses map of images referenced in FBXTree.\n\t * @param {{Objects: {subNodes: {Texture: Object.<string, FBXTextureNode>}}}} FBXTree\n\t * @returns {Map<number, string(image blob URL)>}\n\t */\n  function parseImages(FBXTree) {\n\n\t\t/**\n\t\t * @type {Map<number, string(image blob URL)>}\n\t\t */\n    var imageMap = new Map();\n\n    if ('Video' in FBXTree.Objects.subNodes) {\n\n      var videoNodes = FBXTree.Objects.subNodes.Video;\n\n      for (var nodeID in videoNodes) {\n\n        var videoNode = videoNodes[nodeID];\n\n        // raw image data is in videoNode.properties.Content\n        if ('Content' in videoNode.properties) {\n\n          var image = parseImage(videoNodes[nodeID]);\n          imageMap.set(parseInt(nodeID), image);\n\n        }\n\n      }\n\n    }\n\n    return imageMap;\n\n  }\n\n\t/**\n\t * @param {videoNode} videoNode - Node to get texture image information from.\n\t * @returns {string} - image blob URL\n\t */\n  function parseImage(videoNode) {\n\n    var buffer = videoNode.properties.Content;\n    var array = new Uint8Array(buffer);\n    var fileName = videoNode.properties.RelativeFilename || videoNode.properties.Filename;\n    var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n    var type;\n\n    switch (extension) {\n\n      case 'bmp':\n\n        type = 'image/bmp';\n        break;\n\n      case 'jpg':\n\n        type = 'image/jpeg';\n        break;\n\n      case 'png':\n\n        type = 'image/png';\n        break;\n\n      case 'tif':\n\n        type = 'image/tiff';\n        break;\n\n      default:\n\n        console.warn('FBXLoader: No support image type ' + extension);\n        return;\n\n    }\n\n    return window.URL.createObjectURL(new Blob([array], { type: type }));\n\n  }\n\n\t/**\n\t * Parses map of textures referenced in FBXTree.\n\t * @param {{Objects: {subNodes: {Texture: Object.<string, FBXTextureNode>}}}} FBXTree\n\t * @param {THREE.TextureLoader} loader\n\t * @param {Map<number, string(image blob URL)>} imageMap\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @returns {Map<number, THREE.Texture>}\n\t */\n  function parseTextures(FBXTree, loader, imageMap, connections) {\n\n\t\t/**\n\t\t * @type {Map<number, THREE.Texture>}\n\t\t */\n    var textureMap = new Map();\n\n    if ('Texture' in FBXTree.Objects.subNodes) {\n\n      var textureNodes = FBXTree.Objects.subNodes.Texture;\n      for (var nodeID in textureNodes) {\n\n        var texture = parseTexture(textureNodes[nodeID], loader, imageMap, connections);\n        textureMap.set(parseInt(nodeID), texture);\n\n      }\n\n    }\n\n    return textureMap;\n\n  }\n\n\t/**\n\t * @param {textureNode} textureNode - Node to get texture information from.\n\t * @param {THREE.TextureLoader} loader\n\t * @param {Map<number, string(image blob URL)>} imageMap\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @returns {THREE.Texture}\n\t */\n  function parseTexture(textureNode, loader, imageMap, connections) {\n\n    var FBX_ID = textureNode.id;\n\n    var name = textureNode.name;\n\n    var fileName;\n\n    var filePath = textureNode.properties.FileName;\n    var relativeFilePath = textureNode.properties.RelativeFilename;\n\n    var children = connections.get(FBX_ID).children;\n\n    if (children !== undefined && children.length > 0 && imageMap.has(children[0].ID)) {\n\n      fileName = imageMap.get(children[0].ID);\n\n    } else if (relativeFilePath !== undefined && relativeFilePath[0] !== '/' &&\n      relativeFilePath.match(/^[a-zA-Z]:/) === null) {\n\n      // use textureNode.properties.RelativeFilename\n      // if it exists and it doesn't seem an absolute path\n\n      fileName = relativeFilePath;\n\n    } else {\n\n      var split = filePath.split(/[\\\\\\/]/);\n\n      if (split.length > 0) {\n\n        fileName = split[split.length - 1];\n\n      } else {\n\n        fileName = filePath;\n\n      }\n\n    }\n\n    var currentPath = loader.path;\n\n    if (fileName.indexOf('blob:') === 0) {\n\n      loader.setPath(undefined);\n\n    }\n\n\t\t/**\n\t\t * @type {THREE.Texture}\n\t\t */\n    var texture = loader.load(fileName);\n    texture.name = name;\n    texture.FBX_ID = FBX_ID;\n\n    var wrapModeU = textureNode.properties.WrapModeU;\n    var wrapModeV = textureNode.properties.WrapModeV;\n\n    var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n    var valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n    loader.setPath(currentPath);\n\n    return texture;\n\n  }\n\n\t/**\n\t * Parses map of Material information.\n\t * @param {{Objects: {subNodes: {Material: Object.<number, FBXMaterialNode>}}}} FBXTree\n\t * @param {Map<number, THREE.Texture>} textureMap\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @returns {Map<number, THREE.Material>}\n\t */\n  function parseMaterials(FBXTree, textureMap, connections) {\n\n    var materialMap = new Map();\n\n    if ('Material' in FBXTree.Objects.subNodes) {\n\n      var materialNodes = FBXTree.Objects.subNodes.Material;\n      for (var nodeID in materialNodes) {\n\n        var material = parseMaterial(materialNodes[nodeID], textureMap, connections);\n        materialMap.set(parseInt(nodeID), material);\n\n      }\n\n    }\n\n    return materialMap;\n\n  }\n\n\t/**\n\t * Takes information from Material node and returns a generated THREE.Material\n\t * @param {FBXMaterialNode} materialNode\n\t * @param {Map<number, THREE.Texture>} textureMap\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @returns {THREE.Material}\n\t */\n  function parseMaterial(materialNode, textureMap, connections) {\n\n    var FBX_ID = materialNode.id;\n    var name = materialNode.attrName;\n    var type = materialNode.properties.ShadingModel;\n\n    //Case where FBXs wrap shading model in property object.\n    if (typeof type === 'object') {\n\n      type = type.value;\n\n    }\n\n    var children = connections.get(FBX_ID).children;\n\n    var parameters = parseParameters(materialNode.properties, textureMap, children);\n\n    var material;\n\n    switch (type.toLowerCase()) {\n\n      case 'phong':\n        material = new THREE.MeshPhongMaterial();\n        break;\n      case 'lambert':\n        material = new THREE.MeshLambertMaterial();\n        break;\n      default:\n        console.warn('No implementation given for material type ' + type + ' in FBXLoader.js.  Defaulting to basic material');\n        material = new THREE.MeshBasicMaterial({ color: 0x3300ff });\n        break;\n\n    }\n\n    material.setValues(parameters);\n    material.name = name;\n\n    return material;\n\n  }\n\n\t/**\n\t * @typedef {{Diffuse: FBXVector3, Specular: FBXVector3, Shininess: FBXValue, Emissive: FBXVector3, EmissiveFactor: FBXValue, Opacity: FBXValue}} FBXMaterialProperties\n\t */\n\t/**\n\t * @typedef {{color: THREE.Color=, specular: THREE.Color=, shininess: number=, emissive: THREE.Color=, emissiveIntensity: number=, opacity: number=, transparent: boolean=, map: THREE.Texture=}} THREEMaterialParameterPack\n\t */\n\t/**\n\t * @param {FBXMaterialProperties} properties\n\t * @param {Map<number, THREE.Texture>} textureMap\n\t * @param {{ID: number, relationship: string}[]} childrenRelationships\n\t * @returns {THREEMaterialParameterPack}\n\t */\n  function parseParameters(properties, textureMap, childrenRelationships) {\n\n    var parameters = {};\n\n    if (properties.Diffuse) {\n\n      parameters.color = parseColor(properties.Diffuse);\n\n    }\n    if (properties.Specular) {\n\n      parameters.specular = parseColor(properties.Specular);\n\n    }\n    if (properties.Shininess) {\n\n      parameters.shininess = properties.Shininess.value;\n\n    }\n    if (properties.Emissive) {\n\n      parameters.emissive = parseColor(properties.Emissive);\n\n    }\n    if (properties.EmissiveFactor) {\n\n      parameters.emissiveIntensity = properties.EmissiveFactor.value;\n\n    }\n    if (properties.Opacity) {\n\n      parameters.opacity = properties.Opacity.value;\n\n    }\n    if (parameters.opacity < 1.0) {\n\n      parameters.transparent = true;\n\n    }\n\n    for (var childrenRelationshipsIndex = 0, childrenRelationshipsLength = childrenRelationships.length; childrenRelationshipsIndex < childrenRelationshipsLength; ++childrenRelationshipsIndex) {\n\n      var relationship = childrenRelationships[childrenRelationshipsIndex];\n\n      var type = relationship.relationship;\n\n      switch (type) {\n\n        case \"DiffuseColor\":\n        case \" \\\"DiffuseColor\":\n          parameters.map = textureMap.get(relationship.ID);\n          break;\n\n        case \"Bump\":\n        case \" \\\"Bump\":\n          parameters.bumpMap = textureMap.get(relationship.ID);\n          break;\n\n        case \"NormalMap\":\n        case \" \\\"NormalMap\":\n          parameters.normalMap = textureMap.get(relationship.ID);\n          break;\n\n        case \" \\\"AmbientColor\":\n        case \" \\\"EmissiveColor\":\n        case \"AmbientColor\":\n        case \"EmissiveColor\":\n        default:\n          console.warn('Unknown texture application of type ' + type + ', skipping texture');\n          break;\n\n      }\n\n    }\n\n    return parameters;\n\n  }\n\n\t/**\n\t * Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t * @param {{Objects: {subNodes: {Deformer: Object.<number, FBXSubDeformerNode>}}}} FBXTree\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @returns {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>}\n\t */\n  function parseDeformers(FBXTree, connections) {\n\n    var deformers = {};\n\n    if ('Deformer' in FBXTree.Objects.subNodes) {\n\n      var DeformerNodes = FBXTree.Objects.subNodes.Deformer;\n\n      for (var nodeID in DeformerNodes) {\n\n        var deformerNode = DeformerNodes[nodeID];\n\n        if (deformerNode.attrType === 'Skin') {\n\n          var conns = connections.get(parseInt(nodeID));\n          var skeleton = parseSkeleton(conns, DeformerNodes);\n          skeleton.FBX_ID = parseInt(nodeID);\n\n          deformers[nodeID] = skeleton;\n\n        }\n\n      }\n\n    }\n\n    return deformers;\n\n  }\n\n\t/**\n\t * Generates a \"Skeleton Representation\" of FBX nodes based on an FBX Skin Deformer's connections and an object containing SubDeformer nodes.\n\t * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} connections\n\t * @param {Object.<number, FBXSubDeformerNode>} DeformerNodes\n\t * @returns {{map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}}\n\t */\n  function parseSkeleton(connections, DeformerNodes) {\n\n    var subDeformers = {};\n    var children = connections.children;\n\n    for (var i = 0, l = children.length; i < l; ++i) {\n\n      var child = children[i];\n\n      var subDeformerNode = DeformerNodes[child.ID];\n\n      var subDeformer = {\n        FBX_ID: child.ID,\n        index: i,\n        indices: [],\n        weights: [],\n        transform: parseMatrixArray(subDeformerNode.subNodes.Transform.properties.a),\n        transformLink: parseMatrixArray(subDeformerNode.subNodes.TransformLink.properties.a),\n        linkMode: subDeformerNode.properties.Mode\n      };\n\n      if ('Indexes' in subDeformerNode.subNodes) {\n\n        subDeformer.indices = parseIntArray(subDeformerNode.subNodes.Indexes.properties.a);\n        subDeformer.weights = parseFloatArray(subDeformerNode.subNodes.Weights.properties.a);\n\n      }\n\n      subDeformers[child.ID] = subDeformer;\n\n    }\n\n    return {\n      map: subDeformers,\n      bones: []\n    };\n\n  }\n\n\t/**\n\t * Generates Buffer geometries from geometry information in FBXTree, and generates map of THREE.BufferGeometries\n\t * @param {{Objects: {subNodes: {Geometry: Object.<number, FBXGeometryNode}}}} FBXTree\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>} deformers\n\t * @returns {Map<number, THREE.BufferGeometry>}\n\t */\n  function parseGeometries(FBXTree, connections, deformers) {\n\n    var geometryMap = new Map();\n\n    if ('Geometry' in FBXTree.Objects.subNodes) {\n\n      var geometryNodes = FBXTree.Objects.subNodes.Geometry;\n\n      for (var nodeID in geometryNodes) {\n\n        var relationships = connections.get(parseInt(nodeID));\n        var geo = parseGeometry(geometryNodes[nodeID], relationships, deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n\n      }\n\n    }\n\n    return geometryMap;\n\n  }\n\n\t/**\n\t * Generates BufferGeometry from FBXGeometryNode.\n\t * @param {FBXGeometryNode} geometryNode\n\t * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships\n\t * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}>} deformers\n\t * @returns {THREE.BufferGeometry}\n\t */\n  function parseGeometry(geometryNode, relationships, deformers) {\n\n    switch (geometryNode.attrType) {\n\n      case 'Mesh':\n        return parseMeshGeometry(geometryNode, relationships, deformers);\n        break;\n\n      case 'NurbsCurve':\n        return parseNurbsGeometry(geometryNode);\n        break;\n\n    }\n\n  }\n\n\t/**\n\t * Specialty function for parsing Mesh based Geometry Nodes.\n\t * @param {FBXGeometryNode} geometryNode\n\t * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships - Object representing relationships between specific geometry node and other nodes.\n\t * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}>} deformers - Map object of deformers and subDeformers by ID.\n\t * @returns {THREE.BufferGeometry}\n\t */\n  function parseMeshGeometry(geometryNode, relationships, deformers) {\n\n    for (var i = 0; i < relationships.children.length; ++i) {\n\n      var deformer = deformers[relationships.children[i].ID];\n      if (deformer !== undefined) break;\n\n    }\n\n    return genGeometry(geometryNode, deformer);\n\n  }\n\n\t/**\n\t * @param {{map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[]}} deformer - Skeleton representation for geometry instance.\n\t * @returns {THREE.BufferGeometry}\n\t */\n  function genGeometry(geometryNode, deformer) {\n\n    var geometry = new Geometry();\n\n    var subNodes = geometryNode.subNodes;\n\n    // First, each index is going to be its own vertex.\n\n    var vertexBuffer = parseFloatArray(subNodes.Vertices.properties.a);\n    var indexBuffer = parseIntArray(subNodes.PolygonVertexIndex.properties.a);\n\n    if (subNodes.LayerElementNormal) {\n\n      var normalInfo = getNormals(subNodes.LayerElementNormal[0]);\n\n    }\n\n    if (subNodes.LayerElementUV) {\n\n      var uvInfo = getUVs(subNodes.LayerElementUV[0]);\n\n    }\n\n    if (subNodes.LayerElementColor) {\n\n      var colorInfo = getColors(subNodes.LayerElementColor[0]);\n\n    }\n\n    if (subNodes.LayerElementMaterial) {\n\n      var materialInfo = getMaterials(subNodes.LayerElementMaterial[0]);\n\n    }\n\n    var faceVertexBuffer = [];\n    var polygonIndex = 0;\n\n    for (var polygonVertexIndex = 0; polygonVertexIndex < indexBuffer.length; polygonVertexIndex++) {\n\n      var vertexIndex = indexBuffer[polygonVertexIndex];\n\n      var endOfFace = false;\n\n      if (vertexIndex < 0) {\n\n        vertexIndex = vertexIndex ^ - 1;\n        indexBuffer[polygonVertexIndex] = vertexIndex;\n        endOfFace = true;\n\n      }\n\n      var vertex = new Vertex();\n      var weightIndices = [];\n      var weights = [];\n\n      vertex.position.fromArray(vertexBuffer, vertexIndex * 3);\n\n      if (deformer) {\n\n        var subDeformers = deformer.map;\n\n        for (var key in subDeformers) {\n\n          var subDeformer = subDeformers[key];\n          var indices = subDeformer.indices;\n\n          for (var j = 0; j < indices.length; j++) {\n\n            var index = indices[j];\n\n            if (index === vertexIndex) {\n\n              weights.push(subDeformer.weights[j]);\n              weightIndices.push(subDeformer.index);\n\n              break;\n\n            }\n\n          }\n\n        }\n\n        if (weights.length > 4) {\n\n          console.warn('FBXLoader: Vertex has more than 4 skinning weights assigned to vertex.  Deleting additional weights.');\n\n          var WIndex = [0, 0, 0, 0];\n          var Weight = [0, 0, 0, 0];\n\n          weights.forEach(function (weight, weightIndex) {\n\n            var currentWeight = weight;\n            var currentIndex = weightIndices[weightIndex];\n\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n\n              if (currentWeight > comparedWeight) {\n\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n\n                var tmp = WIndex[comparedWeightIndex];\n                WIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n\n              }\n\n            });\n\n          });\n\n          weightIndices = WIndex;\n          weights = Weight;\n\n        }\n\n        for (var i = weights.length; i < 4; ++i) {\n\n          weights[i] = 0;\n          weightIndices[i] = 0;\n\n        }\n\n        vertex.skinWeights.fromArray(weights);\n        vertex.skinIndices.fromArray(weightIndices);\n\n      }\n\n      if (normalInfo) {\n\n        vertex.normal.fromArray(getData(polygonVertexIndex, polygonIndex, vertexIndex, normalInfo));\n\n      }\n\n      if (uvInfo) {\n\n        vertex.uv.fromArray(getData(polygonVertexIndex, polygonIndex, vertexIndex, uvInfo));\n\n      }\n\n      if (colorInfo) {\n\n        vertex.color.fromArray(getData(polygonVertexIndex, polygonIndex, vertexIndex, colorInfo));\n\n      }\n\n      faceVertexBuffer.push(vertex);\n\n      if (endOfFace) {\n\n        var face = new Face();\n        face.genTrianglesFromVertices(faceVertexBuffer);\n\n        if (materialInfo !== undefined) {\n\n          var materials = getData(polygonVertexIndex, polygonIndex, vertexIndex, materialInfo);\n          face.materialIndex = materials[0];\n\n        } else {\n\n          // Seems like some models don't have materialInfo(subNodes.LayerElementMaterial).\n          // Set 0 in such a case.\n          face.materialIndex = 0;\n\n        }\n\n        geometry.faces.push(face);\n        faceVertexBuffer = [];\n        polygonIndex++;\n\n        endOfFace = false;\n\n      }\n\n    }\n\n\t\t/**\n\t\t * @type {{vertexBuffer: number[], normalBuffer: number[], uvBuffer: number[], skinIndexBuffer: number[], skinWeightBuffer: number[], materialIndexBuffer: number[]}}\n\t\t */\n    var bufferInfo = geometry.flattenToBuffers();\n\n    var geo = new THREE.BufferGeometry();\n    geo.name = geometryNode.name;\n    geo.addAttribute('position', new THREE.Float32BufferAttribute(bufferInfo.vertexBuffer, 3));\n\n    if (bufferInfo.normalBuffer.length > 0) {\n\n      geo.addAttribute('normal', new THREE.Float32BufferAttribute(bufferInfo.normalBuffer, 3));\n\n    }\n    if (bufferInfo.uvBuffer.length > 0) {\n\n      geo.addAttribute('uv', new THREE.Float32BufferAttribute(bufferInfo.uvBuffer, 2));\n\n    }\n    if (subNodes.LayerElementColor) {\n\n      geo.addAttribute('color', new THREE.Float32BufferAttribute(bufferInfo.colorBuffer, 3));\n\n    }\n\n    if (deformer) {\n\n      geo.addAttribute('skinIndex', new THREE.Float32BufferAttribute(bufferInfo.skinIndexBuffer, 4));\n\n      geo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(bufferInfo.skinWeightBuffer, 4));\n\n      geo.FBX_Deformer = deformer;\n\n    }\n\n    // Convert the material indices of each vertex into rendering groups on the geometry.\n\n    var materialIndexBuffer = bufferInfo.materialIndexBuffer;\n    var prevMaterialIndex = materialIndexBuffer[0];\n    var startIndex = 0;\n\n    for (var i = 0; i < materialIndexBuffer.length; ++i) {\n\n      if (materialIndexBuffer[i] !== prevMaterialIndex) {\n\n        geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n\n        prevMaterialIndex = materialIndexBuffer[i];\n        startIndex = i;\n\n      }\n\n    }\n\n    return geo;\n\n  }\n\n\t/**\n\t * Parses normal information for geometry.\n\t * @param {FBXGeometryNode} geometryNode\n\t * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}\n\t */\n  function getNormals(NormalNode) {\n\n    var mappingType = NormalNode.properties.MappingInformationType;\n    var referenceType = NormalNode.properties.ReferenceInformationType;\n    var buffer = parseFloatArray(NormalNode.subNodes.Normals.properties.a);\n    var indexBuffer = [];\n    if (referenceType === 'IndexToDirect') {\n\n      if ('NormalIndex' in NormalNode.subNodes) {\n\n        indexBuffer = parseIntArray(NormalNode.subNodes.NormalIndex.properties.a);\n\n      } else if ('NormalsIndex' in NormalNode.subNodes) {\n\n        indexBuffer = parseIntArray(NormalNode.subNodes.NormalsIndex.properties.a);\n\n      }\n\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n\n  }\n\n\t/**\n\t * Parses UV information for geometry.\n\t * @param {FBXGeometryNode} geometryNode\n\t * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}\n\t */\n  function getUVs(UVNode) {\n\n    var mappingType = UVNode.properties.MappingInformationType;\n    var referenceType = UVNode.properties.ReferenceInformationType;\n    var buffer = parseFloatArray(UVNode.subNodes.UV.properties.a);\n    var indexBuffer = [];\n    if (referenceType === 'IndexToDirect') {\n\n      indexBuffer = parseIntArray(UVNode.subNodes.UVIndex.properties.a);\n\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n\n  }\n\n\t/**\n\t * Parses Vertex Color information for geometry.\n\t * @param {FBXGeometryNode} geometryNode\n\t * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}\n\t */\n  function getColors(ColorNode) {\n\n    var mappingType = ColorNode.properties.MappingInformationType;\n    var referenceType = ColorNode.properties.ReferenceInformationType;\n    var buffer = parseFloatArray(ColorNode.subNodes.Colors.properties.a);\n    var indexBuffer = [];\n    if (referenceType === 'IndexToDirect') {\n\n      indexBuffer = parseFloatArray(ColorNode.subNodes.ColorIndex.properties.a);\n\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n\n  }\n\n\t/**\n\t * Parses material application information for geometry.\n\t * @param {FBXGeometryNode}\n\t * @returns {{dataSize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}}\n\t */\n  function getMaterials(MaterialNode) {\n\n    var mappingType = MaterialNode.properties.MappingInformationType;\n    var referenceType = MaterialNode.properties.ReferenceInformationType;\n\n    if (mappingType === 'NoMappingInformation') {\n\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType\n      };\n\n    }\n\n    var materialIndexBuffer = parseIntArray(MaterialNode.subNodes.Materials.properties.a);\n\n    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.  So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n    var materialIndices = [];\n\n    for (var materialIndexBufferIndex = 0, materialIndexBufferLength = materialIndexBuffer.length; materialIndexBufferIndex < materialIndexBufferLength; ++materialIndexBufferIndex) {\n\n      materialIndices.push(materialIndexBufferIndex);\n\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n\n  }\n\n\t/**\n\t * Function uses the infoObject and given indices to return value array of object.\n\t * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n\t * @param {number} polygonIndex - Index of polygon in geometry.\n\t * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\t * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.\n\t * @returns {number[]}\n\t */\n\n  var dataArray = [];\n\n  var GetData = {\n\n    ByPolygonVertex: {\n\n\t\t\t/**\n\t\t\t * Function uses the infoObject and given indices to return value array of object.\n\t\t\t * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n\t\t\t * @param {number} polygonIndex - Index of polygon in geometry.\n\t\t\t * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\t\t\t * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.\n\t\t\t * @returns {number[]}\n\t\t\t */\n      Direct: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n        var from = (polygonVertexIndex * infoObject.dataSize);\n        var to = (polygonVertexIndex * infoObject.dataSize) + infoObject.dataSize;\n\n        // return infoObject.buffer.slice( from, to );\n        return slice(dataArray, infoObject.buffer, from, to);\n\n      },\n\n\t\t\t/**\n\t\t\t * Function uses the infoObject and given indices to return value array of object.\n\t\t\t * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n\t\t\t * @param {number} polygonIndex - Index of polygon in geometry.\n\t\t\t * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\t\t\t * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.\n\t\t\t * @returns {number[]}\n\t\t\t */\n      IndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n        var index = infoObject.indices[polygonVertexIndex];\n        var from = (index * infoObject.dataSize);\n        var to = (index * infoObject.dataSize) + infoObject.dataSize;\n\n        // return infoObject.buffer.slice( from, to );\n        return slice(dataArray, infoObject.buffer, from, to);\n\n      }\n\n    },\n\n    ByPolygon: {\n\n\t\t\t/**\n\t\t\t * Function uses the infoObject and given indices to return value array of object.\n\t\t\t * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n\t\t\t * @param {number} polygonIndex - Index of polygon in geometry.\n\t\t\t * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\t\t\t * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.\n\t\t\t * @returns {number[]}\n\t\t\t */\n      Direct: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n        var from = polygonIndex * infoObject.dataSize;\n        var to = polygonIndex * infoObject.dataSize + infoObject.dataSize;\n\n        // return infoObject.buffer.slice( from, to );\n        return slice(dataArray, infoObject.buffer, from, to);\n\n      },\n\n\t\t\t/**\n\t\t\t * Function uses the infoObject and given indices to return value array of object.\n\t\t\t * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n\t\t\t * @param {number} polygonIndex - Index of polygon in geometry.\n\t\t\t * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\t\t\t * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.\n\t\t\t * @returns {number[]}\n\t\t\t */\n      IndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n        var index = infoObject.indices[polygonIndex];\n        var from = index * infoObject.dataSize;\n        var to = index * infoObject.dataSize + infoObject.dataSize;\n\n        // return infoObject.buffer.slice( from, to );\n        return slice(dataArray, infoObject.buffer, from, to);\n\n      }\n\n    },\n\n    ByVertice: {\n\n      Direct: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n        var from = (vertexIndex * infoObject.dataSize);\n        var to = (vertexIndex * infoObject.dataSize) + infoObject.dataSize;\n\n        // return infoObject.buffer.slice( from, to );\n        return slice(dataArray, infoObject.buffer, from, to);\n\n      }\n\n    },\n\n    AllSame: {\n\n\t\t\t/**\n\t\t\t * Function uses the infoObject and given indices to return value array of object.\n\t\t\t * @param {number} polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n\t\t\t * @param {number} polygonIndex - Index of polygon in geometry.\n\t\t\t * @param {number} vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\t\t\t * @param {{datasize: number, buffer: number[], indices: number[], mappingType: string, referenceType: string}} infoObject - Object containing data and how to access data.\n\t\t\t * @returns {number[]}\n\t\t\t */\n      IndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n        var from = infoObject.indices[0] * infoObject.dataSize;\n        var to = infoObject.indices[0] * infoObject.dataSize + infoObject.dataSize;\n\n        // return infoObject.buffer.slice( from, to );\n        return slice(dataArray, infoObject.buffer, from, to);\n\n      }\n\n    }\n\n  };\n\n  function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n    return GetData[infoObject.mappingType][infoObject.referenceType](polygonVertexIndex, polygonIndex, vertexIndex, infoObject);\n\n  }\n\n\t/**\n\t * Specialty function for parsing NurbsCurve based Geometry Nodes.\n\t * @param {FBXGeometryNode} geometryNode\n\t * @param {{parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}} relationships\n\t * @returns {THREE.BufferGeometry}\n\t */\n  function parseNurbsGeometry(geometryNode) {\n\n    if (THREE.NURBSCurve === undefined) {\n\n      console.error(\"THREE.FBXLoader relies on THREE.NURBSCurve for any nurbs present in the model.  Nurbs will show up as empty geometry.\");\n      return new THREE.BufferGeometry();\n\n    }\n\n    var order = parseInt(geometryNode.properties.Order);\n\n    if (isNaN(order)) {\n\n      console.error(\"FBXLoader: Invalid Order \" + geometryNode.properties.Order + \" given for geometry ID: \" + geometryNode.id);\n      return new THREE.BufferGeometry();\n\n    }\n\n    var degree = order - 1;\n\n    var knots = parseFloatArray(geometryNode.subNodes.KnotVector.properties.a);\n    var controlPoints = [];\n    var pointsValues = parseFloatArray(geometryNode.subNodes.Points.properties.a);\n\n    for (var i = 0, l = pointsValues.length; i < l; i += 4) {\n\n      controlPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n\n    }\n\n    var startKnot, endKnot;\n\n    if (geometryNode.properties.Form === 'Closed') {\n\n      controlPoints.push(controlPoints[0]);\n\n    } else if (geometryNode.properties.Form === 'Periodic') {\n\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n\n      for (var i = 0; i < degree; ++i) {\n\n        controlPoints.push(controlPoints[i]);\n\n      }\n\n    }\n\n    var curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    var vertices = curve.getPoints(controlPoints.length * 7);\n\n    var positions = new Float32Array(vertices.length * 3);\n\n    for (var i = 0, l = vertices.length; i < l; ++i) {\n\n      vertices[i].toArray(positions, i * 3);\n\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n    return geometry;\n\n  }\n\n\t/**\n\t * Finally generates Scene graph and Scene graph Objects.\n\t * @param {{Objects: {subNodes: {Model: Object.<number, FBXModelNode>}}}} FBXTree\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @param {Map<number, {map: Map<number, {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}>, array: {FBX_ID: number, indices: number[], weights: number[], transform: number[], transformLink: number[], linkMode: string}[], skeleton: THREE.Skeleton|null}>} deformers\n\t * @param {Map<number, THREE.BufferGeometry>} geometryMap\n\t * @param {Map<number, THREE.Material>} materialMap\n\t * @returns {THREE.Group}\n\t */\n  function parseScene(FBXTree, connections, deformers, geometryMap, materialMap) {\n\n    var sceneGraph = new THREE.Group();\n\n    var ModelNode = FBXTree.Objects.subNodes.Model;\n\n\t\t/**\n\t\t * @type {Array.<THREE.Object3D>}\n\t\t */\n    var modelArray = [];\n\n\t\t/**\n\t\t * @type {Map.<number, THREE.Object3D>}\n\t\t */\n    var modelMap = new Map();\n\n    for (var nodeID in ModelNode) {\n\n      var id = parseInt(nodeID);\n      var node = ModelNode[nodeID];\n      var conns = connections.get(id);\n      var model = null;\n\n      for (var i = 0; i < conns.parents.length; ++i) {\n\n        for (var FBX_ID in deformers) {\n\n          var deformer = deformers[FBX_ID];\n          var subDeformers = deformer.map;\n          var subDeformer = subDeformers[conns.parents[i].ID];\n\n          if (subDeformer) {\n\n            var model2 = model;\n            model = new THREE.Bone();\n            deformer.bones[subDeformer.index] = model;\n\n            // seems like we need this not to make non-connected bone, maybe?\n            // TODO: confirm\n            if (model2 !== null) model.add(model2);\n\n          }\n\n        }\n\n      }\n\n      if (!model) {\n\n        switch (node.attrType) {\n\n          case \"Mesh\":\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @type {?THREE.BufferGeometry}\n\t\t\t\t\t\t */\n            var geometry = null;\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @type {THREE.MultiMaterial|THREE.Material}\n\t\t\t\t\t\t */\n            var material = null;\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @type {Array.<THREE.Material>}\n\t\t\t\t\t\t */\n            var materials = [];\n\n            for (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n\n              var child = conns.children[childrenIndex];\n\n              if (geometryMap.has(child.ID)) {\n\n                geometry = geometryMap.get(child.ID);\n\n              }\n\n              if (materialMap.has(child.ID)) {\n\n                materials.push(materialMap.get(child.ID));\n\n              }\n\n            }\n            if (materials.length > 1) {\n\n              material = materials;\n\n            } else if (materials.length > 0) {\n\n              material = materials[0];\n\n            } else {\n\n              material = new THREE.MeshBasicMaterial({ color: 0x3300ff });\n              materials.push(material);\n\n            }\n            if ('color' in geometry.attributes) {\n\n              for (var materialIndex = 0, numMaterials = materials.length; materialIndex < numMaterials; ++materialIndex) {\n\n                materials[materialIndex].vertexColors = THREE.VertexColors;\n\n              }\n\n            }\n            if (geometry.FBX_Deformer) {\n\n              for (var materialsIndex = 0, materialsLength = materials.length; materialsIndex < materialsLength; ++materialsIndex) {\n\n                materials[materialsIndex].skinning = true;\n\n              }\n              model = new THREE.SkinnedMesh(geometry, material);\n\n            } else {\n\n              model = new THREE.Mesh(geometry, material);\n\n            }\n            break;\n\n          case \"NurbsCurve\":\n            var geometry = null;\n\n            for (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n\n              var child = conns.children[childrenIndex];\n\n              if (geometryMap.has(child.ID)) {\n\n                geometry = geometryMap.get(child.ID);\n\n              }\n\n            }\n\n            // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n            material = new THREE.LineBasicMaterial({ color: 0x3300ff, linewidth: 5 });\n            model = new THREE.Line(geometry, material);\n            break;\n\n          default:\n            model = new THREE.Object3D();\n            break;\n\n        }\n\n      }\n\n      model.name = node.attrName.replace(/:/, '').replace(/_/, '').replace(/-/, '');\n      model.FBX_ID = id;\n\n      modelArray.push(model);\n      modelMap.set(id, model);\n\n    }\n\n    for (var modelArrayIndex = 0, modelArrayLength = modelArray.length; modelArrayIndex < modelArrayLength; ++modelArrayIndex) {\n\n      var model = modelArray[modelArrayIndex];\n\n      var node = ModelNode[model.FBX_ID];\n\n      if ('Lcl_Translation' in node.properties) {\n\n        model.position.fromArray(parseFloatArray(node.properties.Lcl_Translation.value));\n\n      }\n\n      if ('Lcl_Rotation' in node.properties) {\n\n        var rotation = parseFloatArray(node.properties.Lcl_Rotation.value).map(degreeToRadian);\n        rotation.push('ZYX');\n        model.rotation.fromArray(rotation);\n\n      }\n\n      if ('Lcl_Scaling' in node.properties) {\n\n        model.scale.fromArray(parseFloatArray(node.properties.Lcl_Scaling.value));\n\n      }\n\n      if ('PreRotation' in node.properties) {\n\n        var preRotations = new THREE.Euler().setFromVector3(parseVector3(node.properties.PreRotation).multiplyScalar(DEG2RAD), 'ZYX');\n        preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n        var currentRotation = new THREE.Quaternion().setFromEuler(model.rotation);\n        preRotations.multiply(currentRotation);\n        model.rotation.setFromQuaternion(preRotations, 'ZYX');\n\n      }\n\n      var conns = connections.get(model.FBX_ID);\n      for (var parentIndex = 0; parentIndex < conns.parents.length; parentIndex++) {\n\n        var pIndex = findIndex(modelArray, function (mod) {\n\n          return mod.FBX_ID === conns.parents[parentIndex].ID;\n\n        });\n        if (pIndex > - 1) {\n\n          modelArray[pIndex].add(model);\n          break;\n\n        }\n\n      }\n      if (model.parent === null) {\n\n        sceneGraph.add(model);\n\n      }\n\n    }\n\n\n    // Now with the bones created, we can update the skeletons and bind them to the skinned meshes.\n    sceneGraph.updateMatrixWorld(true);\n\n    // Put skeleton into bind pose.\n    var BindPoseNode = FBXTree.Objects.subNodes.Pose;\n    for (var nodeID in BindPoseNode) {\n\n      if (BindPoseNode[nodeID].attrType === 'BindPose') {\n\n        BindPoseNode = BindPoseNode[nodeID];\n        break;\n\n      }\n\n    }\n    if (BindPoseNode) {\n\n      var PoseNode = BindPoseNode.subNodes.PoseNode;\n      var worldMatrices = new Map();\n\n      for (var PoseNodeIndex = 0, PoseNodeLength = PoseNode.length; PoseNodeIndex < PoseNodeLength; ++PoseNodeIndex) {\n\n        var node = PoseNode[PoseNodeIndex];\n\n        var rawMatWrd = parseMatrixArray(node.subNodes.Matrix.properties.a);\n\n        worldMatrices.set(parseInt(node.id), rawMatWrd);\n\n      }\n\n    }\n\n    for (var FBX_ID in deformers) {\n\n      var deformer = deformers[FBX_ID];\n      var subDeformers = deformer.map;\n\n      for (var key in subDeformers) {\n\n        var subDeformer = subDeformers[key];\n        var subDeformerIndex = subDeformer.index;\n\n\t\t\t\t/**\n\t\t\t\t * @type {THREE.Bone}\n\t\t\t\t */\n        var bone = deformer.bones[subDeformerIndex];\n        if (!worldMatrices.has(bone.FBX_ID)) {\n\n          break;\n\n        }\n        var mat = worldMatrices.get(bone.FBX_ID);\n        bone.matrixWorld.copy(mat);\n\n      }\n\n      // Now that skeleton is in bind pose, bind to model.\n      deformer.skeleton = new THREE.Skeleton(deformer.bones);\n\n      var conns = connections.get(deformer.FBX_ID);\n      var parents = conns.parents;\n\n      for (var parentsIndex = 0, parentsLength = parents.length; parentsIndex < parentsLength; ++parentsIndex) {\n\n        var parent = parents[parentsIndex];\n\n        if (geometryMap.has(parent.ID)) {\n\n          var geoID = parent.ID;\n          var geoConns = connections.get(geoID);\n\n          for (var i = 0; i < geoConns.parents.length; ++i) {\n\n            if (modelMap.has(geoConns.parents[i].ID)) {\n\n              var model = modelMap.get(geoConns.parents[i].ID);\n              //ASSERT model typeof SkinnedMesh\n              model.bind(deformer.skeleton, model.matrixWorld);\n              break;\n\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n    //Skeleton is now bound, return objects to starting\n    //world positions.\n    sceneGraph.updateMatrixWorld(true);\n\n    // Silly hack with the animation parsing.  We're gonna pretend the scene graph has a skeleton\n    // to attach animations to, since FBXs treat animations as animations for the entire scene,\n    // not just for individual objects.\n    sceneGraph.skeleton = {\n      bones: modelArray\n    };\n\n    var animations = parseAnimations(FBXTree, connections, sceneGraph);\n\n    addAnimations(sceneGraph, animations);\n\n    return sceneGraph;\n\n  }\n\n\t/**\n\t * Parses animation information from FBXTree and generates an AnimationInfoObject.\n\t * @param {{Objects: {subNodes: {AnimationCurveNode: any, AnimationCurve: any, AnimationLayer: any, AnimationStack: any}}}} FBXTree\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t */\n  function parseAnimations(FBXTree, connections, sceneGraph) {\n\n    var rawNodes = FBXTree.Objects.subNodes.AnimationCurveNode;\n    var rawCurves = FBXTree.Objects.subNodes.AnimationCurve;\n    var rawLayers = FBXTree.Objects.subNodes.AnimationLayer;\n    var rawStacks = FBXTree.Objects.subNodes.AnimationStack;\n\n\t\t/**\n\t\t * @type {{\n\t\t\t\t curves: Map<number, {\n\t\t\t\t T: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t R: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t S: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t }>,\n\t\t\t layers: Map<number, {\n\t\t\t\tT: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tR: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tS: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\t}[]>,\n\t\t\t stacks: Map<number, {\n\t\t\t\t name: string,\n\t\t\t\t layers: {\n\t\t\t\t\tT: {\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tattr: string;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\tattrX: boolean;\n\t\t\t\t\t\tattrY: boolean;\n\t\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\t\tcontainerID: number;\n\t\t\t\t\t\tcurves: {\n\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t\tR: {\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tattr: string;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\tattrX: boolean;\n\t\t\t\t\t\tattrY: boolean;\n\t\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\t\tcontainerID: number;\n\t\t\t\t\t\tcurves: {\n\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t\tS: {\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tattr: string;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\tattrX: boolean;\n\t\t\t\t\t\tattrY: boolean;\n\t\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\t\tcontainerID: number;\n\t\t\t\t\t\tcurves: {\n\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t}[][],\n\t\t\t length: number,\n\t\t\t frames: number }>,\n\t\t\t length: number,\n\t\t\t fps: number,\n\t\t\t frames: number\n\t\t }}\n\t\t */\n    var returnObject = {\n      curves: new Map(),\n      layers: {},\n      stacks: {},\n      length: 0,\n      fps: 30,\n      frames: 0\n    };\n\n\t\t/**\n\t\t * @type {Array.<{\n\t\t\t\tid: number;\n\t\t\t\tattr: string;\n\t\t\t\tinternalID: number;\n\t\t\t\tattrX: boolean;\n\t\t\t\tattrY: boolean;\n\t\t\t\tattrZ: boolean;\n\t\t\t\tcontainerBoneID: number;\n\t\t\t\tcontainerID: number;\n\t\t\t}>}\n\t\t */\n    var animationCurveNodes = [];\n    for (var nodeID in rawNodes) {\n\n      if (nodeID.match(/\\d+/)) {\n\n        var animationNode = parseAnimationNode(FBXTree, rawNodes[nodeID], connections, sceneGraph);\n        animationCurveNodes.push(animationNode);\n\n      }\n\n    }\n\n\t\t/**\n\t\t * @type {Map.<number, {\n\t\t\t\tid: number,\n\t\t\t\tattr: string,\n\t\t\t\tinternalID: number,\n\t\t\t\tattrX: boolean,\n\t\t\t\tattrY: boolean,\n\t\t\t\tattrZ: boolean,\n\t\t\t\tcontainerBoneID: number,\n\t\t\t\tcontainerID: number,\n\t\t\t\tcurves: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t},\n\t\t\t\t\ty: {\n\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t},\n\t\t\t\t\tz: {\n\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}>}\n\t\t */\n    var tmpMap = new Map();\n    for (var animationCurveNodeIndex = 0; animationCurveNodeIndex < animationCurveNodes.length; ++animationCurveNodeIndex) {\n\n      if (animationCurveNodes[animationCurveNodeIndex] === null) {\n\n        continue;\n\n      }\n      tmpMap.set(animationCurveNodes[animationCurveNodeIndex].id, animationCurveNodes[animationCurveNodeIndex]);\n\n    }\n\n\n\t\t/**\n\t\t * @type {{\n\t\t\t\tversion: any,\n\t\t\t\tid: number,\n\t\t\t\tinternalID: number,\n\t\t\t\ttimes: number[],\n\t\t\t\tvalues: number[],\n\t\t\t\tattrFlag: number[],\n\t\t\t\tattrData: number[],\n\t\t\t}[]}\n\t\t */\n    var animationCurves = [];\n    for (nodeID in rawCurves) {\n\n      if (nodeID.match(/\\d+/)) {\n\n        var animationCurve = parseAnimationCurve(rawCurves[nodeID]);\n\n        // seems like this check would be necessary?\n        if (!connections.has(animationCurve.id)) continue;\n\n        animationCurves.push(animationCurve);\n\n        var firstParentConn = connections.get(animationCurve.id).parents[0];\n        var firstParentID = firstParentConn.ID;\n        var firstParentRelationship = firstParentConn.relationship;\n        var axis = '';\n\n        if (firstParentRelationship.match(/X/)) {\n\n          axis = 'x';\n\n        } else if (firstParentRelationship.match(/Y/)) {\n\n          axis = 'y';\n\n        } else if (firstParentRelationship.match(/Z/)) {\n\n          axis = 'z';\n\n        } else {\n\n          continue;\n\n        }\n\n        tmpMap.get(firstParentID).curves[axis] = animationCurve;\n\n      }\n\n    }\n\n    tmpMap.forEach(function (curveNode) {\n\n      var id = curveNode.containerBoneID;\n      if (!returnObject.curves.has(id)) {\n\n        returnObject.curves.set(id, { T: null, R: null, S: null });\n\n      }\n      returnObject.curves.get(id)[curveNode.attr] = curveNode;\n      if (curveNode.attr === 'R') {\n\n        var curves = curveNode.curves;\n        curves.x.values = curves.x.values.map(degreeToRadian);\n        curves.y.values = curves.y.values.map(degreeToRadian);\n        curves.z.values = curves.z.values.map(degreeToRadian);\n\n        if (curveNode.preRotations !== null) {\n\n          var preRotations = new THREE.Euler().setFromVector3(curveNode.preRotations, 'ZYX');\n          preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n          var frameRotation = new THREE.Euler();\n          var frameRotationQuaternion = new THREE.Quaternion();\n          for (var frame = 0; frame < curves.x.times.length; ++frame) {\n\n            frameRotation.set(curves.x.values[frame], curves.y.values[frame], curves.z.values[frame], 'ZYX');\n            frameRotationQuaternion.setFromEuler(frameRotation).premultiply(preRotations);\n            frameRotation.setFromQuaternion(frameRotationQuaternion, 'ZYX');\n            curves.x.values[frame] = frameRotation.x;\n            curves.y.values[frame] = frameRotation.y;\n            curves.z.values[frame] = frameRotation.z;\n\n          }\n\n        }\n\n      }\n\n    });\n\n    for (var nodeID in rawLayers) {\n\n\t\t\t/**\n\t\t\t * @type {{\n\t\t\t\tT: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tR: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tS: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\t}[]}\n\t\t\t */\n      var layer = [];\n      var children = connections.get(parseInt(nodeID)).children;\n\n      for (var childIndex = 0; childIndex < children.length; childIndex++) {\n\n        // Skip lockInfluenceWeights\n        if (tmpMap.has(children[childIndex].ID)) {\n\n          var curveNode = tmpMap.get(children[childIndex].ID);\n          var boneID = curveNode.containerBoneID;\n          if (layer[boneID] === undefined) {\n\n            layer[boneID] = {\n              T: null,\n              R: null,\n              S: null\n            };\n\n          }\n\n          layer[boneID][curveNode.attr] = curveNode;\n\n        }\n\n      }\n\n      returnObject.layers[nodeID] = layer;\n\n    }\n\n    for (var nodeID in rawStacks) {\n\n      var layers = [];\n      var children = connections.get(parseInt(nodeID)).children;\n      var timestamps = { max: 0, min: Number.MAX_VALUE };\n\n      for (var childIndex = 0; childIndex < children.length; ++childIndex) {\n\n        var currentLayer = returnObject.layers[children[childIndex].ID];\n\n        if (currentLayer !== undefined) {\n\n          layers.push(currentLayer);\n\n          for (var currentLayerIndex = 0, currentLayerLength = currentLayer.length; currentLayerIndex < currentLayerLength; ++currentLayerIndex) {\n\n            var layer = currentLayer[currentLayerIndex];\n\n            if (layer) {\n\n              getCurveNodeMaxMinTimeStamps(layer, timestamps);\n\n            }\n\n          }\n\n        }\n\n      }\n\n      // Do we have an animation clip with actual length?\n      if (timestamps.max > timestamps.min) {\n\n        returnObject.stacks[nodeID] = {\n          name: rawStacks[nodeID].attrName,\n          layers: layers,\n          length: timestamps.max - timestamps.min,\n          frames: (timestamps.max - timestamps.min) * 30\n        };\n\n      }\n\n    }\n\n    return returnObject;\n\n  }\n\n\t/**\n\t * @param {Object} FBXTree\n\t * @param {{id: number, attrName: string, properties: Object<string, any>}} animationCurveNode\n\t * @param {Map<number, {parents: {ID: number, relationship: string}[], children: {ID: number, relationship: string}[]}>} connections\n\t * @param {{skeleton: {bones: {FBX_ID: number}[]}}} sceneGraph\n\t */\n  function parseAnimationNode(FBXTree, animationCurveNode, connections, sceneGraph) {\n\n    var rawModels = FBXTree.Objects.subNodes.Model;\n\n    var returnObject = {\n\t\t\t/**\n\t\t\t * @type {number}\n\t\t\t */\n      id: animationCurveNode.id,\n\n\t\t\t/**\n\t\t\t * @type {string}\n\t\t\t */\n      attr: animationCurveNode.attrName,\n\n\t\t\t/**\n\t\t\t * @type {number}\n\t\t\t */\n      internalID: animationCurveNode.id,\n\n\t\t\t/**\n\t\t\t * @type {boolean}\n\t\t\t */\n      attrX: false,\n\n\t\t\t/**\n\t\t\t * @type {boolean}\n\t\t\t */\n      attrY: false,\n\n\t\t\t/**\n\t\t\t * @type {boolean}\n\t\t\t */\n      attrZ: false,\n\n\t\t\t/**\n\t\t\t * @type {number}\n\t\t\t */\n      containerBoneID: - 1,\n\n\t\t\t/**\n\t\t\t * @type {number}\n\t\t\t */\n      containerID: - 1,\n\n      curves: {\n        x: null,\n        y: null,\n        z: null\n      },\n\n\t\t\t/**\n\t\t\t * @type {number[]}\n\t\t\t */\n      preRotations: null\n    };\n\n    if (returnObject.attr.match(/S|R|T/)) {\n\n      for (var attributeKey in animationCurveNode.properties) {\n\n        if (attributeKey.match(/X/)) {\n\n          returnObject.attrX = true;\n\n        }\n        if (attributeKey.match(/Y/)) {\n\n          returnObject.attrY = true;\n\n        }\n        if (attributeKey.match(/Z/)) {\n\n          returnObject.attrZ = true;\n\n        }\n\n      }\n\n    } else {\n\n      return null;\n\n    }\n\n    var conns = connections.get(returnObject.id);\n    var containerIndices = conns.parents;\n\n    for (var containerIndicesIndex = containerIndices.length - 1; containerIndicesIndex >= 0; --containerIndicesIndex) {\n\n      var boneID = findIndex(sceneGraph.skeleton.bones, function (bone) {\n\n        return bone.FBX_ID === containerIndices[containerIndicesIndex].ID;\n\n      });\n      if (boneID > - 1) {\n\n        returnObject.containerBoneID = boneID;\n        returnObject.containerID = containerIndices[containerIndicesIndex].ID;\n        var model = rawModels[returnObject.containerID.toString()];\n        if ('PreRotation' in model.properties) {\n\n          returnObject.preRotations = parseVector3(model.properties.PreRotation).multiplyScalar(Math.PI / 180);\n\n        }\n        break;\n\n      }\n\n    }\n\n    return returnObject;\n\n  }\n\n\t/**\n\t * @param {{id: number, subNodes: {KeyTime: {properties: {a: string}}, KeyValueFloat: {properties: {a: string}}, KeyAttrFlags: {properties: {a: string}}, KeyAttrDataFloat: {properties: {a: string}}}}} animationCurve\n\t */\n  function parseAnimationCurve(animationCurve) {\n\n    return {\n      version: null,\n      id: animationCurve.id,\n      internalID: animationCurve.id,\n      times: parseFloatArray(animationCurve.subNodes.KeyTime.properties.a).map(convertFBXTimeToSeconds),\n      values: parseFloatArray(animationCurve.subNodes.KeyValueFloat.properties.a),\n\n      attrFlag: parseIntArray(animationCurve.subNodes.KeyAttrFlags.properties.a),\n      attrData: parseFloatArray(animationCurve.subNodes.KeyAttrDataFloat.properties.a)\n    };\n\n  }\n\n\t/**\n\t * Sets the maxTimeStamp and minTimeStamp variables if it has timeStamps that are either larger or smaller\n\t * than the max or min respectively.\n\t * @param {{\n\t\t\t\tT: {\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tattr: string,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\tattrX: boolean,\n\t\t\t\t\t\tattrY: boolean,\n\t\t\t\t\t\tattrZ: boolean,\n\t\t\t\t\t\tcontainerBoneID: number,\n\t\t\t\t\t\tcontainerID: number,\n\t\t\t\t\t\tcurves: {\n\t\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tR: {\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tattr: string,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\tattrX: boolean,\n\t\t\t\t\t\tattrY: boolean,\n\t\t\t\t\t\tattrZ: boolean,\n\t\t\t\t\t\tcontainerBoneID: number,\n\t\t\t\t\t\tcontainerID: number,\n\t\t\t\t\t\tcurves: {\n\t\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tS: {\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tattr: string,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\tattrX: boolean,\n\t\t\t\t\t\tattrY: boolean,\n\t\t\t\t\t\tattrZ: boolean,\n\t\t\t\t\t\tcontainerBoneID: number,\n\t\t\t\t\t\tcontainerID: number,\n\t\t\t\t\t\tcurves: {\n\t\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\t\t\t\t\tid: number,\n\t\t\t\t\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\t\t\t\t\tattrData: number[],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t},\n\t\t}} layer\n\t */\n  function getCurveNodeMaxMinTimeStamps(layer, timestamps) {\n\n    if (layer.R) {\n\n      getCurveMaxMinTimeStamp(layer.R.curves, timestamps);\n\n    }\n    if (layer.S) {\n\n      getCurveMaxMinTimeStamp(layer.S.curves, timestamps);\n\n    }\n    if (layer.T) {\n\n      getCurveMaxMinTimeStamp(layer.T.curves, timestamps);\n\n    }\n\n  }\n\n\t/**\n\t * Sets the maxTimeStamp and minTimeStamp if one of the curve's time stamps\n\t * exceeds the maximum or minimum.\n\t * @param {{\n\t\t\t\tx: {\n\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\tattrData: number[],\n\t\t\t\t},\n\t\t\t\ty: {\n\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\tattrData: number[],\n\t\t\t\t},\n\t\t\t\tz: {\n\t\t\t\t\t\tversion: any,\n\t\t\t\t\t\tid: number,\n\t\t\t\t\t\tinternalID: number,\n\t\t\t\t\t\ttimes: number[],\n\t\t\t\t\t\tvalues: number[],\n\t\t\t\t\t\tattrFlag: number[],\n\t\t\t\t\t\tattrData: number[],\n\t\t\t\t}\n\t\t}} curve\n\t */\n  function getCurveMaxMinTimeStamp(curve, timestamps) {\n\n    if (curve.x) {\n\n      getCurveAxisMaxMinTimeStamps(curve.x, timestamps);\n\n    }\n    if (curve.y) {\n\n      getCurveAxisMaxMinTimeStamps(curve.y, timestamps);\n\n    }\n    if (curve.z) {\n\n      getCurveAxisMaxMinTimeStamps(curve.z, timestamps);\n\n    }\n\n  }\n\n\t/**\n\t * Sets the maxTimeStamp and minTimeStamp if one of its timestamps exceeds the maximum or minimum.\n\t * @param {{times: number[]}} axis\n\t */\n  function getCurveAxisMaxMinTimeStamps(axis, timestamps) {\n\n    timestamps.max = axis.times[axis.times.length - 1] > timestamps.max ? axis.times[axis.times.length - 1] : timestamps.max;\n    timestamps.min = axis.times[0] < timestamps.min ? axis.times[0] : timestamps.min;\n\n  }\n\n\t/**\n\t * @param {{\n\t\tcurves: Map<number, {\n\t\t\tT: {\n\t\t\t\tid: number;\n\t\t\t\tattr: string;\n\t\t\t\tinternalID: number;\n\t\t\t\tattrX: boolean;\n\t\t\t\tattrY: boolean;\n\t\t\t\tattrZ: boolean;\n\t\t\t\tcontainerBoneID: number;\n\t\t\t\tcontainerID: number;\n\t\t\t\tcurves: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\ty: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\tz: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tR: {\n\t\t\t\tid: number;\n\t\t\t\tattr: string;\n\t\t\t\tinternalID: number;\n\t\t\t\tattrX: boolean;\n\t\t\t\tattrY: boolean;\n\t\t\t\tattrZ: boolean;\n\t\t\t\tcontainerBoneID: number;\n\t\t\t\tcontainerID: number;\n\t\t\t\tcurves: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\ty: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\tz: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tS: {\n\t\t\t\tid: number;\n\t\t\t\tattr: string;\n\t\t\t\tinternalID: number;\n\t\t\t\tattrX: boolean;\n\t\t\t\tattrY: boolean;\n\t\t\t\tattrZ: boolean;\n\t\t\t\tcontainerBoneID: number;\n\t\t\t\tcontainerID: number;\n\t\t\t\tcurves: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\ty: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\tz: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t}>;\n\t\tlayers: Map<number, {\n\t\t\tT: {\n\t\t\t\tid: number;\n\t\t\t\tattr: string;\n\t\t\t\tinternalID: number;\n\t\t\t\tattrX: boolean;\n\t\t\t\tattrY: boolean;\n\t\t\t\tattrZ: boolean;\n\t\t\t\tcontainerBoneID: number;\n\t\t\t\tcontainerID: number;\n\t\t\t\tcurves: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\ty: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\tz: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tR: {\n\t\t\t\tid: number;\n\t\t\t\tattr: string;\n\t\t\t\tinternalID: number;\n\t\t\t\tattrX: boolean;\n\t\t\t\tattrY: boolean;\n\t\t\t\tattrZ: boolean;\n\t\t\t\tcontainerBoneID: number;\n\t\t\t\tcontainerID: number;\n\t\t\t\tcurves: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\ty: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\tz: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tS: {\n\t\t\t\tid: number;\n\t\t\t\tattr: string;\n\t\t\t\tinternalID: number;\n\t\t\t\tattrX: boolean;\n\t\t\t\tattrY: boolean;\n\t\t\t\tattrZ: boolean;\n\t\t\t\tcontainerBoneID: number;\n\t\t\t\tcontainerID: number;\n\t\t\t\tcurves: {\n\t\t\t\t\tx: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\ty: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t\tz: {\n\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\tid: number;\n\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t}[]>;\n\t\tstacks: Map<number, {\n\t\t\tname: string;\n\t\t\tlayers: {\n\t\t\t\tT: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tR: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tS: {\n\t\t\t\t\tid: number;\n\t\t\t\t\tattr: string;\n\t\t\t\t\tinternalID: number;\n\t\t\t\t\tattrX: boolean;\n\t\t\t\t\tattrY: boolean;\n\t\t\t\t\tattrZ: boolean;\n\t\t\t\t\tcontainerBoneID: number;\n\t\t\t\t\tcontainerID: number;\n\t\t\t\t\tcurves: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\ty: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t\tz: {\n\t\t\t\t\t\t\tversion: any;\n\t\t\t\t\t\t\tid: number;\n\t\t\t\t\t\t\tinternalID: number;\n\t\t\t\t\t\t\ttimes: number[];\n\t\t\t\t\t\t\tvalues: number[];\n\t\t\t\t\t\t\tattrFlag: number[];\n\t\t\t\t\t\t\tattrData: number[];\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}[][];\n\t\t\tlength: number;\n\t\t\tframes: number;\n\t\t}>;\n\t\tlength: number;\n\t\tfps: number;\n\t\tframes: number;\n\t}} animations,\n\t * @param {{skeleton: { bones: THREE.Bone[]}}} group\n\t */\n  function addAnimations(group, animations) {\n\n    if (group.animations === undefined) {\n\n      group.animations = [];\n\n    }\n\n    var stacks = animations.stacks;\n\n    for (var key in stacks) {\n\n      var stack = stacks[key];\n\n\t\t\t/**\n\t\t\t * @type {{\n\t\t\t * name: string,\n\t\t\t * fps: number,\n\t\t\t * length: number,\n\t\t\t * hierarchy: Array.<{\n\t\t\t * \tparent: number,\n\t\t\t * \tname: string,\n\t\t\t * \tkeys: Array.<{\n\t\t\t * \t\ttime: number,\n\t\t\t * \t\tpos: Array.<number>,\n\t\t\t * \t\trot: Array.<number>,\n\t\t\t * \t\tscl: Array.<number>\n\t\t\t * \t}>\n\t\t\t * }>\n\t\t\t * }}\n\t\t\t */\n      var animationData = {\n        name: stack.name,\n        fps: 30,\n        length: stack.length,\n        hierarchy: []\n      };\n\n      var bones = group.skeleton.bones;\n\n      for (var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++bonesIndex) {\n\n        var bone = bones[bonesIndex];\n\n        var name = bone.name.replace(/.*:/, '');\n        var parentIndex = findIndex(bones, function (parentBone) {\n\n          return bone.parent === parentBone;\n\n        });\n        animationData.hierarchy.push({ parent: parentIndex, name: name, keys: [] });\n\n      }\n\n      for (var frame = 0; frame <= stack.frames; frame++) {\n\n        for (var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++bonesIndex) {\n\n          var bone = bones[bonesIndex];\n          var boneIndex = bonesIndex;\n\n          var animationNode = stack.layers[0][boneIndex];\n\n          for (var hierarchyIndex = 0, hierarchyLength = animationData.hierarchy.length; hierarchyIndex < hierarchyLength; ++hierarchyIndex) {\n\n            var node = animationData.hierarchy[hierarchyIndex];\n\n            if (node.name === bone.name) {\n\n              node.keys.push(generateKey(animations, animationNode, bone, frame));\n\n            }\n\n          }\n\n        }\n\n      }\n\n      group.animations.push(THREE.AnimationClip.parseAnimation(animationData, bones));\n\n    }\n\n  }\n\n  var euler = new THREE.Euler();\n  var quaternion = new THREE.Quaternion();\n\n\t/**\n\t * @param {THREE.Bone} bone\n\t */\n  function generateKey(animations, animationNode, bone, frame) {\n\n    var key = {\n      time: frame / animations.fps,\n      pos: bone.position.toArray(),\n      rot: bone.quaternion.toArray(),\n      scl: bone.scale.toArray()\n    };\n\n    if (animationNode === undefined) return key;\n\n    try {\n\n      if (hasCurve(animationNode, 'T') && hasKeyOnFrame(animationNode.T, frame)) {\n\n        key.pos = [animationNode.T.curves.x.values[frame], animationNode.T.curves.y.values[frame], animationNode.T.curves.z.values[frame]];\n\n      }\n\n      if (hasCurve(animationNode, 'R') && hasKeyOnFrame(animationNode.R, frame)) {\n\n        var rotationX = animationNode.R.curves.x.values[frame];\n        var rotationY = animationNode.R.curves.y.values[frame];\n        var rotationZ = animationNode.R.curves.z.values[frame];\n\n        quaternion.setFromEuler(euler.set(rotationX, rotationY, rotationZ, 'ZYX'));\n        key.rot = quaternion.toArray();\n\n      }\n\n      if (hasCurve(animationNode, 'S') && hasKeyOnFrame(animationNode.S, frame)) {\n\n        key.scl = [animationNode.S.curves.x.values[frame], animationNode.S.curves.y.values[frame], animationNode.S.curves.z.values[frame]];\n\n      }\n\n    } catch (error) {\n\n      // Curve is not fully plotted.\n      console.log(bone);\n      console.log(error);\n\n    }\n\n    return key;\n\n  }\n\n  var AXES = ['x', 'y', 'z'];\n\n  function hasCurve(animationNode, attribute) {\n\n    if (animationNode === undefined) {\n\n      return false;\n\n    }\n\n    var attributeNode = animationNode[attribute];\n\n    if (!attributeNode) {\n\n      return false;\n\n    }\n\n    return AXES.every(function (key) {\n\n      return attributeNode.curves[key] !== null;\n\n    });\n\n  }\n\n  function hasKeyOnFrame(attributeNode, frame) {\n\n    return AXES.every(function (key) {\n\n      return isKeyExistOnFrame(attributeNode.curves[key], frame);\n\n    });\n\n  }\n\n  function isKeyExistOnFrame(curve, frame) {\n\n    return curve.values[frame] !== undefined;\n\n  }\n\n\t/**\n\t * An instance of a Vertex with data for drawing vertices to the screen.\n\t * @constructor\n\t */\n  function Vertex() {\n\n\t\t/**\n\t\t * Position of the vertex.\n\t\t * @type {THREE.Vector3}\n\t\t */\n    this.position = new THREE.Vector3();\n\n\t\t/**\n\t\t * Normal of the vertex\n\t\t * @type {THREE.Vector3}\n\t\t */\n    this.normal = new THREE.Vector3();\n\n\t\t/**\n\t\t * UV coordinates of the vertex.\n\t\t * @type {THREE.Vector2}\n\t\t */\n    this.uv = new THREE.Vector2();\n\n\t\t/**\n\t\t * Color of the vertex\n\t\t * @type {THREE.Vector3}\n\t\t */\n    this.color = new THREE.Vector3();\n\n\t\t/**\n\t\t * Indices of the bones vertex is influenced by.\n\t\t * @type {THREE.Vector4}\n\t\t */\n    this.skinIndices = new THREE.Vector4(0, 0, 0, 0);\n\n\t\t/**\n\t\t * Weights that each bone influences the vertex.\n\t\t * @type {THREE.Vector4}\n\t\t */\n    this.skinWeights = new THREE.Vector4(0, 0, 0, 0);\n\n  }\n\n  Object.assign(Vertex.prototype, {\n\n    copy: function (target) {\n\n      var returnVar = target || new Vertex();\n\n      returnVar.position.copy(this.position);\n      returnVar.normal.copy(this.normal);\n      returnVar.uv.copy(this.uv);\n      returnVar.skinIndices.copy(this.skinIndices);\n      returnVar.skinWeights.copy(this.skinWeights);\n\n      return returnVar;\n\n    },\n\n    flattenToBuffers: function (vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer) {\n\n      this.position.toArray(vertexBuffer, vertexBuffer.length);\n      this.normal.toArray(normalBuffer, normalBuffer.length);\n      this.uv.toArray(uvBuffer, uvBuffer.length);\n      this.color.toArray(colorBuffer, colorBuffer.length);\n      this.skinIndices.toArray(skinIndexBuffer, skinIndexBuffer.length);\n      this.skinWeights.toArray(skinWeightBuffer, skinWeightBuffer.length);\n\n    }\n\n  });\n\n\t/**\n\t * @constructor\n\t */\n  function Triangle() {\n\n\t\t/**\n\t\t * @type {{position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}\n\t\t */\n    this.vertices = [];\n\n  }\n\n  Object.assign(Triangle.prototype, {\n\n    copy: function (target) {\n\n      var returnVar = target || new Triangle();\n\n      for (var i = 0; i < this.vertices.length; ++i) {\n\n        this.vertices[i].copy(returnVar.vertices[i]);\n\n      }\n\n      return returnVar;\n\n    },\n\n    flattenToBuffers: function (vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer) {\n\n      var vertices = this.vertices;\n\n      for (var i = 0, l = vertices.length; i < l; ++i) {\n\n        vertices[i].flattenToBuffers(vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer);\n\n      }\n\n    }\n\n  });\n\n\t/**\n\t * @constructor\n\t */\n  function Face() {\n\n\t\t/**\n\t\t * @type {{vertices: {position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}[]}\n\t\t */\n    this.triangles = [];\n    this.materialIndex = 0;\n\n  }\n\n  Object.assign(Face.prototype, {\n\n    copy: function (target) {\n\n      var returnVar = target || new Face();\n\n      for (var i = 0; i < this.triangles.length; ++i) {\n\n        this.triangles[i].copy(returnVar.triangles[i]);\n\n      }\n\n      returnVar.materialIndex = this.materialIndex;\n\n      return returnVar;\n\n    },\n\n    genTrianglesFromVertices: function (vertexArray) {\n\n      for (var i = 2; i < vertexArray.length; ++i) {\n\n        var triangle = new Triangle();\n        triangle.vertices[0] = vertexArray[0];\n        triangle.vertices[1] = vertexArray[i - 1];\n        triangle.vertices[2] = vertexArray[i];\n        this.triangles.push(triangle);\n\n      }\n\n    },\n\n    flattenToBuffers: function (vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer, materialIndexBuffer) {\n\n      var triangles = this.triangles;\n      var materialIndex = this.materialIndex;\n\n      for (var i = 0, l = triangles.length; i < l; ++i) {\n\n        triangles[i].flattenToBuffers(vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer);\n        append(materialIndexBuffer, [materialIndex, materialIndex, materialIndex]);\n\n      }\n\n    }\n\n  });\n\n\t/**\n\t * @constructor\n\t */\n  function Geometry() {\n\n\t\t/**\n\t\t * @type {{triangles: {vertices: {position: THREE.Vector3, normal: THREE.Vector3, uv: THREE.Vector2, skinIndices: THREE.Vector4, skinWeights: THREE.Vector4}[]}[], materialIndex: number}[]}\n\t\t */\n    this.faces = [];\n\n\t\t/**\n\t\t * @type {{}|THREE.Skeleton}\n\t\t */\n    this.skeleton = null;\n\n  }\n\n  Object.assign(Geometry.prototype, {\n\n\t\t/**\n\t\t * @returns\t{{vertexBuffer: number[], normalBuffer: number[], uvBuffer: number[], skinIndexBuffer: number[], skinWeightBuffer: number[], materialIndexBuffer: number[]}}\n\t\t */\n    flattenToBuffers: function () {\n\n      var vertexBuffer = [];\n      var normalBuffer = [];\n      var uvBuffer = [];\n      var colorBuffer = [];\n      var skinIndexBuffer = [];\n      var skinWeightBuffer = [];\n\n      var materialIndexBuffer = [];\n\n      var faces = this.faces;\n\n      for (var i = 0, l = faces.length; i < l; ++i) {\n\n        faces[i].flattenToBuffers(vertexBuffer, normalBuffer, uvBuffer, colorBuffer, skinIndexBuffer, skinWeightBuffer, materialIndexBuffer);\n\n      }\n\n      return {\n        vertexBuffer: vertexBuffer,\n        normalBuffer: normalBuffer,\n        uvBuffer: uvBuffer,\n        colorBuffer: colorBuffer,\n        skinIndexBuffer: skinIndexBuffer,\n        skinWeightBuffer: skinWeightBuffer,\n        materialIndexBuffer: materialIndexBuffer\n      };\n\n    }\n\n  });\n\n  function TextParser() { }\n\n  Object.assign(TextParser.prototype, {\n\n    getPrevNode: function () {\n\n      return this.nodeStack[this.currentIndent - 2];\n\n    },\n\n    getCurrentNode: function () {\n\n      return this.nodeStack[this.currentIndent - 1];\n\n    },\n\n    getCurrentProp: function () {\n\n      return this.currentProp;\n\n    },\n\n    pushStack: function (node) {\n\n      this.nodeStack.push(node);\n      this.currentIndent += 1;\n\n    },\n\n    popStack: function () {\n\n      this.nodeStack.pop();\n      this.currentIndent -= 1;\n\n    },\n\n    setCurrentProp: function (val, name) {\n\n      this.currentProp = val;\n      this.currentPropName = name;\n\n    },\n\n    // ----------parse ---------------------------------------------------\n    parse: function (text) {\n\n      this.currentIndent = 0;\n      this.allNodes = new FBXTree();\n      this.nodeStack = [];\n      this.currentProp = [];\n      this.currentPropName = '';\n\n      var split = text.split(\"\\n\");\n\n      for (var line in split) {\n\n        var l = split[line];\n\n        // short cut\n        if (l.match(/^[\\s\\t]*;/)) {\n\n          continue;\n\n        } // skip comment line\n        if (l.match(/^[\\s\\t]*$/)) {\n\n          continue;\n\n        } // skip empty line\n\n        // beginning of node\n        var beginningOfNodeExp = new RegExp(\"^\\\\t{\" + this.currentIndent + \"}(\\\\w+):(.*){\", '');\n        var match = l.match(beginningOfNodeExp);\n        if (match) {\n\n          var nodeName = match[1].trim().replace(/^\"/, '').replace(/\"$/, \"\");\n          var nodeAttrs = match[2].split(',');\n\n          for (var i = 0, l = nodeAttrs.length; i < l; i++) {\n            nodeAttrs[i] = nodeAttrs[i].trim().replace(/^\"/, '').replace(/\"$/, '');\n          }\n\n          this.parseNodeBegin(l, nodeName, nodeAttrs || null);\n          continue;\n\n        }\n\n        // node's property\n        var propExp = new RegExp(\"^\\\\t{\" + (this.currentIndent) + \"}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)\");\n        var match = l.match(propExp);\n        if (match) {\n\n          var propName = match[1].replace(/^\"/, '').replace(/\"$/, \"\").trim();\n          var propValue = match[2].replace(/^\"/, '').replace(/\"$/, \"\").trim();\n\n          this.parseNodeProperty(l, propName, propValue);\n          continue;\n\n        }\n\n        // end of node\n        var endOfNodeExp = new RegExp(\"^\\\\t{\" + (this.currentIndent - 1) + \"}}\");\n        if (l.match(endOfNodeExp)) {\n\n          this.nodeEnd();\n          continue;\n\n        }\n\n        // for special case,\n        //\n        //\t  Vertices: *8670 {\n        //\t\t  a: 0.0356229953467846,13.9599733352661,-0.399196773.....(snip)\n        // -0.0612030513584614,13.960485458374,-0.409748703241348,-0.10.....\n        // 0.12490539252758,13.7450733184814,-0.454119384288788,0.09272.....\n        // 0.0836158767342567,13.5432004928589,-0.435397416353226,0.028.....\n        //\n        // these case the lines must contiue with previous line\n        if (l.match(/^[^\\s\\t}]/)) {\n\n          this.parseNodePropertyContinued(l);\n\n        }\n\n      }\n\n      return this.allNodes;\n\n    },\n\n    parseNodeBegin: function (line, nodeName, nodeAttrs) {\n\n      // var nodeName = match[1];\n      var node = { 'name': nodeName, properties: {}, 'subNodes': {} };\n      var attrs = this.parseNodeAttr(nodeAttrs);\n      var currentNode = this.getCurrentNode();\n\n      // a top node\n      if (this.currentIndent === 0) {\n\n        this.allNodes.add(nodeName, node);\n\n      } else {\n\n        // a subnode\n\n        // already exists subnode, then append it\n        if (nodeName in currentNode.subNodes) {\n\n          var tmp = currentNode.subNodes[nodeName];\n\n          // console.log( \"duped entry found\\nkey: \" + nodeName + \"\\nvalue: \" + propValue );\n          if (this.isFlattenNode(currentNode.subNodes[nodeName])) {\n\n\n            if (attrs.id === '') {\n\n              currentNode.subNodes[nodeName] = [];\n              currentNode.subNodes[nodeName].push(tmp);\n\n            } else {\n\n              currentNode.subNodes[nodeName] = {};\n              currentNode.subNodes[nodeName][tmp.id] = tmp;\n\n            }\n\n          }\n\n          if (attrs.id === '') {\n\n            currentNode.subNodes[nodeName].push(node);\n\n          } else {\n\n            currentNode.subNodes[nodeName][attrs.id] = node;\n\n          }\n\n        } else if (typeof attrs.id === 'number' || attrs.id.match(/^\\d+$/)) {\n\n          currentNode.subNodes[nodeName] = {};\n          currentNode.subNodes[nodeName][attrs.id] = node;\n\n        } else {\n\n          currentNode.subNodes[nodeName] = node;\n\n        }\n\n      }\n\n      // for this\t\t  \n      // NodeAttribute: 1001463072, \"NodeAttribute::\", \"LimbNode\" {\n      if (nodeAttrs) {\n\n        node.id = attrs.id;\n        node.attrName = attrs.name;\n        node.attrType = attrs.type;\n\n      }\n\n      this.pushStack(node);\n\n    },\n\n    parseNodeAttr: function (attrs) {\n\n      var id = attrs[0];\n\n      if (attrs[0] !== \"\") {\n\n        id = parseInt(attrs[0]);\n\n        if (isNaN(id)) {\n\n          // PolygonVertexIndex: *16380 {\n          id = attrs[0];\n\n        }\n\n      }\n\n      var name = '', type = '';\n\n      if (attrs.length > 1) {\n\n        name = attrs[1].replace(/^(\\w+)::/, '');\n        type = attrs[2];\n\n      }\n\n      return { id: id, name: name, type: type };\n\n    },\n\n    parseNodeProperty: function (line, propName, propValue) {\n\n      var currentNode = this.getCurrentNode();\n      var parentName = currentNode.name;\n\n      // special case parent node's is like \"Properties70\"\n      // these chilren nodes must treat with careful\n      if (parentName !== undefined) {\n\n        var propMatch = parentName.match(/Properties(\\d)+/);\n        if (propMatch) {\n\n          this.parseNodeSpecialProperty(line, propName, propValue);\n          return;\n\n        }\n\n      }\n\n      // special case Connections\n      if (propName == 'C') {\n\n        var connProps = propValue.split(',').slice(1);\n        var from = parseInt(connProps[0]);\n        var to = parseInt(connProps[1]);\n\n        var rest = propValue.split(',').slice(3);\n\n        propName = 'connections';\n        propValue = [from, to];\n        append(propValue, rest);\n\n        if (currentNode.properties[propName] === undefined) {\n\n          currentNode.properties[propName] = [];\n\n        }\n\n      }\n\n      // special case Connections\n      if (propName == 'Node') {\n\n        var id = parseInt(propValue);\n        currentNode.properties.id = id;\n        currentNode.id = id;\n\n      }\n\n      // already exists in properties, then append this\n      if (propName in currentNode.properties) {\n\n        // console.log( \"duped entry found\\nkey: \" + propName + \"\\nvalue: \" + propValue );\n        if (Array.isArray(currentNode.properties[propName])) {\n\n          currentNode.properties[propName].push(propValue);\n\n        } else {\n\n          currentNode.properties[propName] += propValue;\n\n        }\n\n      } else {\n\n        // console.log( propName + \":  \" + propValue );\n        if (Array.isArray(currentNode.properties[propName])) {\n\n          currentNode.properties[propName].push(propValue);\n\n        } else {\n\n          currentNode.properties[propName] = propValue;\n\n        }\n\n      }\n\n      this.setCurrentProp(currentNode.properties, propName);\n\n    },\n\n    // TODO:\n    parseNodePropertyContinued: function (line) {\n\n      this.currentProp[this.currentPropName] += line;\n\n    },\n\n    parseNodeSpecialProperty: function (line, propName, propValue) {\n\n      // split this\n      // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n      // into array like below\n      // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n      var props = propValue.split('\",');\n\n      for (var i = 0, l = props.length; i < l; i++) {\n        props[i] = props[i].trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n      }\n\n      var innerPropName = props[0];\n      var innerPropType1 = props[1];\n      var innerPropType2 = props[2];\n      var innerPropFlag = props[3];\n      var innerPropValue = props[4];\n\n\t\t\t/*\n\t\t\tif ( innerPropValue === undefined ) {\n\t\t\t\tinnerPropValue = props[3];\n\t\t\t}\n\t\t\t*/\n\n      // cast value in its type\n      switch (innerPropType1) {\n\n        case \"int\":\n          innerPropValue = parseInt(innerPropValue);\n          break;\n\n        case \"double\":\n          innerPropValue = parseFloat(innerPropValue);\n          break;\n\n        case \"ColorRGB\":\n        case \"Vector3D\":\n          innerPropValue = parseFloatArray(innerPropValue);\n          break;\n\n      }\n\n      // CAUTION: these props must append to parent's parent\n      this.getPrevNode().properties[innerPropName] = {\n\n        'type': innerPropType1,\n        'type2': innerPropType2,\n        'flag': innerPropFlag,\n        'value': innerPropValue\n\n      };\n\n      this.setCurrentProp(this.getPrevNode().properties, innerPropName);\n\n    },\n\n    nodeEnd: function () {\n\n      this.popStack();\n\n    },\n\n    /* ---------------------------------------------------------------- */\n    /*\t\tutil\t\t\t\t\t\t\t\t\t\t\t\t\t  */\n    isFlattenNode: function (node) {\n\n      return ('subNodes' in node && 'properties' in node) ? true : false;\n\n    }\n\n  });\n\n  // Binary format specification:\n  //   https://code.blender.org/2013/08/fbx-binary-file-format-specification/\n  //   https://wiki.rogiken.org/specifications/file-format/fbx/ (more detail but Japanese)\n  function BinaryParser() { }\n\n  Object.assign(BinaryParser.prototype, {\n\n\t\t/**\n\t\t * Parses binary data and builds FBXTree as much compatible as possible with the one built by TextParser.\n\t\t * @param {ArrayBuffer} buffer\n\t\t * @returns {THREE.FBXTree}\n\t\t */\n    parse: function (buffer) {\n\n      var reader = new BinaryReader(buffer);\n      reader.skip(23); // skip magic 23 bytes\n\n      var version = reader.getUint32();\n\n      console.log('FBX binary version: ' + version);\n\n      var allNodes = new FBXTree();\n\n      while (!this.endOfContent(reader)) {\n\n        var node = this.parseNode(reader, version);\n        if (node !== null) allNodes.add(node.name, node);\n\n      }\n\n      return allNodes;\n\n    },\n\n\t\t/**\n\t\t * Checks if reader has reached the end of content.\n\t\t * @param {BinaryReader} reader\n\t\t * @returns {boolean}\n\t\t */\n    endOfContent: function (reader) {\n\n      // footer size: 160bytes + 16-byte alignment padding\n      // - 16bytes: magic\n      // - padding til 16-byte alignment (at least 1byte?)\n      //   (seems like some exporters embed fixed 15bytes?)\n      // - 4bytes: magic\n      // - 4bytes: version\n      // - 120bytes: zero\n      // - 16bytes: magic\n      if (reader.size() % 16 === 0) {\n\n        return ((reader.getOffset() + 160 + 16) & ~0xf) >= reader.size();\n\n      } else {\n\n        return reader.getOffset() + 160 + 15 >= reader.size();\n\n      }\n\n    },\n\n\t\t/**\n\t\t * Parses Node as much compatible as possible with the one parsed by TextParser\n\t\t * TODO: could be optimized more?\n\t\t * @param {BinaryReader} reader\n\t\t * @param {number} version\n\t\t * @returns {Object} - Returns an Object as node, or null if NULL-record.\n\t\t */\n    parseNode: function (reader, version) {\n\n      // The first three data sizes depends on version.\n      var endOffset = (version >= 7500) ? reader.getUint64() : reader.getUint32();\n      var numProperties = (version >= 7500) ? reader.getUint64() : reader.getUint32();\n      var propertyListLen = (version >= 7500) ? reader.getUint64() : reader.getUint32();\n      var nameLen = reader.getUint8();\n      var name = reader.getString(nameLen);\n\n      // Regards this node as NULL-record if endOffset is zero\n      if (endOffset === 0) return null;\n\n      var propertyList = [];\n\n      for (var i = 0; i < numProperties; i++) {\n\n        propertyList.push(this.parseProperty(reader));\n\n      }\n\n      // Regards the first three elements in propertyList as id, attrName, and attrType\n      var id = propertyList.length > 0 ? propertyList[0] : '';\n      var attrName = propertyList.length > 1 ? propertyList[1] : '';\n      var attrType = propertyList.length > 2 ? propertyList[2] : '';\n\n      var subNodes = {};\n      var properties = {};\n\n      var isSingleProperty = false;\n\n      // if this node represents just a single property\n      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n      if (numProperties === 1 && reader.getOffset() === endOffset) {\n\n        isSingleProperty = true;\n\n      }\n\n      while (endOffset > reader.getOffset()) {\n\n        var node = this.parseNode(reader, version);\n\n        if (node === null) continue;\n\n        // special case: child node is single property\n        if (node.singleProperty === true) {\n\n          var value = node.propertyList[0];\n\n          if (Array.isArray(value)) {\n\n            // node represents\n            //\tVertices: *3 {\n            //\t\ta: 0.01, 0.02, 0.03\n            //\t}\n            // of text format here.\n\n            node.properties[node.name] = node.propertyList[0];\n            subNodes[node.name] = node;\n\n            // Later phase expects single property array is in node.properties.a as String.\n            // TODO: optimize\n            node.properties.a = value.toString();\n\n          } else {\n\n            // node represents\n            // \tVersion: 100\n            // of text format here.\n\n            properties[node.name] = value;\n\n          }\n\n          continue;\n\n        }\n\n        // special case: connections\n        if (name === 'Connections' && node.name === 'C') {\n\n          var array = [];\n\n          // node.propertyList would be like\n          // [\"OO\", 111264976, 144038752, \"d|x\"] (?, from, to, additional values)\n          for (var i = 1, il = node.propertyList.length; i < il; i++) {\n\n            array[i - 1] = node.propertyList[i];\n\n          }\n\n          if (properties.connections === undefined) {\n\n            properties.connections = [];\n\n          }\n\n          properties.connections.push(array);\n\n          continue;\n\n        }\n\n        // special case: child node is Properties\\d+\n        if (node.name.match(/^Properties\\d+$/)) {\n\n          // move child node's properties to this node.\n\n          var keys = Object.keys(node.properties);\n\n          for (var i = 0, il = keys.length; i < il; i++) {\n\n            var key = keys[i];\n            properties[key] = node.properties[key];\n\n          }\n\n          continue;\n\n        }\n\n        // special case: properties\n        if (name.match(/^Properties\\d+$/) && node.name === 'P') {\n\n          var innerPropName = node.propertyList[0];\n          var innerPropType1 = node.propertyList[1];\n          var innerPropType2 = node.propertyList[2];\n          var innerPropFlag = node.propertyList[3];\n          var innerPropValue;\n\n          if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n          if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n          if (innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' ||\n            innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n\n            innerPropValue = [\n              node.propertyList[4],\n              node.propertyList[5],\n              node.propertyList[6]\n            ];\n\n          } else {\n\n            innerPropValue = node.propertyList[4];\n\n          }\n\n          if (innerPropType1.indexOf('Lcl_') === 0) {\n\n            innerPropValue = innerPropValue.toString();\n\n          }\n\n          // this will be copied to parent. see above.\n          properties[innerPropName] = {\n\n            'type': innerPropType1,\n            'type2': innerPropType2,\n            'flag': innerPropFlag,\n            'value': innerPropValue\n\n          };\n\n          continue;\n\n        }\n\n        // standard case\n        // follows TextParser's manner.\n        if (subNodes[node.name] === undefined) {\n\n          if (typeof node.id === 'number') {\n\n            subNodes[node.name] = {};\n            subNodes[node.name][node.id] = node;\n\n          } else {\n\n            subNodes[node.name] = node;\n\n          }\n\n        } else {\n\n          if (node.id === '') {\n\n            if (!Array.isArray(subNodes[node.name])) {\n\n              subNodes[node.name] = [subNodes[node.name]];\n\n            }\n\n            subNodes[node.name].push(node);\n\n          } else {\n\n            if (subNodes[node.name][node.id] === undefined) {\n\n              subNodes[node.name][node.id] = node;\n\n            } else {\n\n              // conflict id. irregular?\n\n              if (!Array.isArray(subNodes[node.name][node.id])) {\n\n                subNodes[node.name][node.id] = [subNodes[node.name][node.id]];\n\n              }\n\n              subNodes[node.name][node.id].push(node);\n\n            }\n\n          }\n\n        }\n\n      }\n\n      return {\n\n        singleProperty: isSingleProperty,\n        id: id,\n        attrName: attrName,\n        attrType: attrType,\n        name: name,\n        properties: properties,\n        propertyList: propertyList, // raw property list, would be used by parent\n        subNodes: subNodes\n\n      };\n\n    },\n\n    parseProperty: function (reader) {\n\n      var type = reader.getChar();\n\n      switch (type) {\n\n        case 'F':\n          return reader.getFloat32();\n\n        case 'D':\n          return reader.getFloat64();\n\n        case 'L':\n          return reader.getInt64();\n\n        case 'I':\n          return reader.getInt32();\n\n        case 'Y':\n          return reader.getInt16();\n\n        case 'C':\n          return reader.getBoolean();\n\n        case 'f':\n        case 'd':\n        case 'l':\n        case 'i':\n        case 'b':\n\n          var arrayLength = reader.getUint32();\n          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n          var compressedLength = reader.getUint32();\n\n          if (encoding === 0) {\n\n            switch (type) {\n\n              case 'f':\n                return reader.getFloat32Array(arrayLength);\n\n              case 'd':\n                return reader.getFloat64Array(arrayLength);\n\n              case 'l':\n                return reader.getInt64Array(arrayLength);\n\n              case 'i':\n                return reader.getInt32Array(arrayLength);\n\n              case 'b':\n                return reader.getBooleanArray(arrayLength);\n\n            }\n\n          }\n\n          if (window.Zlib === undefined) {\n\n            throw new Error('FBXLoader: Import inflate.min.js from https://github.com/imaya/zlib.js');\n\n          }\n\n          var inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength)));\n          var reader2 = new BinaryReader(inflate.decompress().buffer);\n\n          switch (type) {\n\n            case 'f':\n              return reader2.getFloat32Array(arrayLength);\n\n            case 'd':\n              return reader2.getFloat64Array(arrayLength);\n\n            case 'l':\n              return reader2.getInt64Array(arrayLength);\n\n            case 'i':\n              return reader2.getInt32Array(arrayLength);\n\n            case 'b':\n              return reader2.getBooleanArray(arrayLength);\n\n          }\n\n        case 'S':\n          var length = reader.getUint32();\n          return reader.getString(length);\n\n        case 'R':\n          var length = reader.getUint32();\n          return reader.getArrayBuffer(length);\n\n        default:\n          throw new Error('FBXLoader: Unknown property type ' + type);\n\n      }\n\n    }\n\n  });\n\n\n  function BinaryReader(buffer, littleEndian) {\n\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = (littleEndian !== undefined) ? littleEndian : true;\n\n  }\n\n  Object.assign(BinaryReader.prototype, {\n\n    getOffset: function () {\n\n      return this.offset;\n\n    },\n\n    size: function () {\n\n      return this.dv.buffer.byteLength;\n\n    },\n\n    skip: function (length) {\n\n      this.offset += length;\n\n    },\n\n    // seems like true/false representation depends on exporter.\n    //   true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n    // then sees LSB.\n    getBoolean: function () {\n\n      return (this.getUint8() & 1) === 1;\n\n    },\n\n    getBooleanArray: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getBoolean());\n\n      }\n\n      return a;\n\n    },\n\n    getInt8: function () {\n\n      var value = this.dv.getInt8(this.offset);\n      this.offset += 1;\n      return value;\n\n    },\n\n    getInt8Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getInt8());\n\n      }\n\n      return a;\n\n    },\n\n    getUint8: function () {\n\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n\n    },\n\n    getUint8Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getUint8());\n\n      }\n\n      return a;\n\n    },\n\n    getInt16: function () {\n\n      var value = this.dv.getInt16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n\n    },\n\n    getInt16Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getInt16());\n\n      }\n\n      return a;\n\n    },\n\n    getUint16: function () {\n\n      var value = this.dv.getUint16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n\n    },\n\n    getUint16Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getUint16());\n\n      }\n\n      return a;\n\n    },\n\n    getInt32: function () {\n\n      var value = this.dv.getInt32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n\n    },\n\n    getInt32Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getInt32());\n\n      }\n\n      return a;\n\n    },\n\n    getUint32: function () {\n\n      var value = this.dv.getUint32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n\n    },\n\n    getUint32Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getUint32());\n\n      }\n\n      return a;\n\n    },\n\n    // JavaScript doesn't support 64-bit integer so attempting to calculate by ourselves.\n    // 1 << 32 will return 1 so using multiply operation instead here.\n    // There'd be a possibility that this method returns wrong value if the value\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n    // TODO: safely handle 64-bit integer\n    getInt64: function () {\n\n      var low, high;\n\n      if (this.littleEndian) {\n\n        low = this.getUint32();\n        high = this.getUint32();\n\n      } else {\n\n        high = this.getUint32();\n        low = this.getUint32();\n\n      }\n\n      // calculate negative value\n      if (high & 0x80000000) {\n\n        high = ~high & 0xFFFFFFFF;\n        low = ~low & 0xFFFFFFFF;\n\n        if (low === 0xFFFFFFFF) high = (high + 1) & 0xFFFFFFFF;\n\n        low = (low + 1) & 0xFFFFFFFF;\n\n        return - (high * 0x100000000 + low);\n\n      }\n\n      return high * 0x100000000 + low;\n\n    },\n\n    getInt64Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getInt64());\n\n      }\n\n      return a;\n\n    },\n\n    // Note: see getInt64() comment\n    getUint64: function () {\n\n      var low, high;\n\n      if (this.littleEndian) {\n\n        low = this.getUint32();\n        high = this.getUint32();\n\n      } else {\n\n        high = this.getUint32();\n        low = this.getUint32();\n\n      }\n\n      return high * 0x100000000 + low;\n\n    },\n\n    getUint64Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getUint64());\n\n      }\n\n      return a;\n\n    },\n\n    getFloat32: function () {\n\n      var value = this.dv.getFloat32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n\n    },\n\n    getFloat32Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getFloat32());\n\n      }\n\n      return a;\n\n    },\n\n    getFloat64: function () {\n\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n\n    },\n\n    getFloat64Array: function (size) {\n\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n\n        a.push(this.getFloat64());\n\n      }\n\n      return a;\n\n    },\n\n    getArrayBuffer: function (size) {\n\n      var value = this.dv.buffer.slice(this.offset, this.offset + size);\n      this.offset += size;\n      return value;\n\n    },\n\n    getChar: function () {\n\n      return String.fromCharCode(this.getUint8());\n\n    },\n\n    getString: function (size) {\n\n      var s = '';\n\n      while (size > 0) {\n\n        var value = this.getUint8();\n        size--;\n\n        if (value === 0) break;\n\n        s += String.fromCharCode(value);\n\n      }\n\n      this.skip(size);\n\n      return s;\n\n    }\n\n  });\n\n\n  function FBXTree() { }\n\n  Object.assign(FBXTree.prototype, {\n\n    add: function (key, val) {\n\n      this[key] = val;\n\n    },\n\n    searchConnectionParent: function (id) {\n\n      if (this.__cache_search_connection_parent === undefined) {\n\n        this.__cache_search_connection_parent = [];\n\n      }\n\n      if (this.__cache_search_connection_parent[id] !== undefined) {\n\n        return this.__cache_search_connection_parent[id];\n\n      } else {\n\n        this.__cache_search_connection_parent[id] = [];\n\n      }\n\n      var conns = this.Connections.properties.connections;\n\n      var results = [];\n      for (var i = 0; i < conns.length; ++i) {\n\n        if (conns[i][0] == id) {\n\n          // 0 means scene root\n          var res = conns[i][1] === 0 ? - 1 : conns[i][1];\n          results.push(res);\n\n        }\n\n      }\n\n      if (results.length > 0) {\n\n        append(this.__cache_search_connection_parent[id], results);\n        return results;\n\n      } else {\n\n        this.__cache_search_connection_parent[id] = [- 1];\n        return [- 1];\n\n      }\n\n    },\n\n    searchConnectionChildren: function (id) {\n\n      if (this.__cache_search_connection_children === undefined) {\n\n        this.__cache_search_connection_children = [];\n\n      }\n\n      if (this.__cache_search_connection_children[id] !== undefined) {\n\n        return this.__cache_search_connection_children[id];\n\n      } else {\n\n        this.__cache_search_connection_children[id] = [];\n\n      }\n\n      var conns = this.Connections.properties.connections;\n\n      var res = [];\n      for (var i = 0; i < conns.length; ++i) {\n\n        if (conns[i][1] == id) {\n\n          // 0 means scene root\n          res.push(conns[i][0] === 0 ? - 1 : conns[i][0]);\n          // there may more than one kid, then search to the end\n\n        }\n\n      }\n\n      if (res.length > 0) {\n\n        append(this.__cache_search_connection_children[id], res);\n        return res;\n\n      } else {\n\n        this.__cache_search_connection_children[id] = [];\n        return [];\n\n      }\n\n    },\n\n    searchConnectionType: function (id, to) {\n\n      var key = id + ',' + to; // TODO: to hash\n      if (this.__cache_search_connection_type === undefined) {\n\n        this.__cache_search_connection_type = {};\n\n      }\n\n      if (this.__cache_search_connection_type[key] !== undefined) {\n\n        return this.__cache_search_connection_type[key];\n\n      } else {\n\n        this.__cache_search_connection_type[key] = '';\n\n      }\n\n      var conns = this.Connections.properties.connections;\n\n      for (var i = 0; i < conns.length; ++i) {\n\n        if (conns[i][0] == id && conns[i][1] == to) {\n\n          // 0 means scene root\n          this.__cache_search_connection_type[key] = conns[i][2];\n          return conns[i][2];\n\n        }\n\n      }\n\n      this.__cache_search_connection_type[id] = null;\n      return null;\n\n    }\n\n  });\n\n\n\t/**\n\t * @param {ArrayBuffer} buffer\n\t * @returns {boolean}\n\t */\n  function isFbxFormatBinary(buffer) {\n\n    var CORRECT = 'Kaydara FBX Binary  \\0';\n\n    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n\n  }\n\n\t/**\n\t * @returns {boolean}\n\t */\n  function isFbxFormatASCII(text) {\n\n    var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n\n    var cursor = 0;\n\n    function read(offset) {\n\n      var result = text[offset - 1];\n      text = text.slice(cursor + offset);\n      cursor++;\n      return result;\n\n    }\n\n    for (var i = 0; i < CORRECT.length; ++i) {\n\n      var num = read(1);\n      if (num == CORRECT[i]) {\n\n        return false;\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n\t/**\n\t * @returns {number}\n\t */\n  function getFbxVersion(text) {\n\n    var versionRegExp = /FBXVersion: (\\d+)/;\n    var match = text.match(versionRegExp);\n    if (match) {\n\n      var version = parseInt(match[1]);\n      return version;\n\n    }\n    throw new Error('FBXLoader: Cannot find the version number for the file given.');\n\n  }\n\n\t/**\n\t * Converts FBX ticks into real time seconds.\n\t * @param {number} time - FBX tick timestamp to convert.\n\t * @returns {number} - FBX tick in real world time.\n\t */\n  function convertFBXTimeToSeconds(time) {\n\n    // Constant is FBX ticks per second.\n    return time / 46186158000;\n\n  }\n\n\t/**\n\t * Parses comma separated list of float numbers and returns them in an array.\n\t * @example\n\t * // Returns [ 5.6, 9.4, 2.5, 1.4 ]\n\t * parseFloatArray( \"5.6,9.4,2.5,1.4\" )\n\t * @returns {number[]}\n\t */\n  function parseFloatArray(string) {\n\n    var array = string.split(',');\n\n    for (var i = 0, l = array.length; i < l; i++) {\n\n      array[i] = parseFloat(array[i]);\n\n    }\n\n    return array;\n\n  }\n\n\t/**\n\t * Parses comma separated list of int numbers and returns them in an array.\n\t * @example\n\t * // Returns [ 5, 8, 2, 3 ]\n\t * parseFloatArray( \"5,8,2,3\" )\n\t * @returns {number[]}\n\t */\n  function parseIntArray(string) {\n\n    var array = string.split(',');\n\n    for (var i = 0, l = array.length; i < l; i++) {\n\n      array[i] = parseInt(array[i]);\n\n    }\n\n    return array;\n\n  }\n\n\t/**\n\t * Parses Vector3 property from FBXTree.  Property is given as .value.x, .value.y, etc.\n\t * @param {FBXVector3} property - Property to parse as Vector3.\n\t * @returns {THREE.Vector3}\n\t */\n  function parseVector3(property) {\n\n    return new THREE.Vector3().fromArray(property.value);\n\n  }\n\n\t/**\n\t * Parses Color property from FBXTree.  Property is given as .value.x, .value.y, etc.\n\t * @param {FBXVector3} property - Property to parse as Color.\n\t * @returns {THREE.Color}\n\t */\n  function parseColor(property) {\n\n    return new THREE.Color().fromArray(property.value);\n\n  }\n\n  function parseMatrixArray(floatString) {\n\n    return new THREE.Matrix4().fromArray(parseFloatArray(floatString));\n\n  }\n\n\t/**\n\t * Converts ArrayBuffer to String.\n\t * @param {ArrayBuffer} buffer\n\t * @param {number} from\n\t * @param {number} to\n\t * @returns {String}\n\t */\n  function convertArrayBufferToString(buffer, from, to) {\n\n    if (from === undefined) from = 0;\n    if (to === undefined) to = buffer.byteLength;\n\n    var array = new Uint8Array(buffer, from, to);\n\n    if (window.TextDecoder !== undefined) {\n\n      return new TextDecoder().decode(array);\n\n    }\n\n    var s = '';\n\n    for (var i = 0, il = array.length; i < il; i++) {\n\n      s += String.fromCharCode(array[i]);\n\n    }\n\n    return s;\n\n  }\n\n\t/**\n\t * Converts number from degrees into radians.\n\t * @param {number} value\n\t * @returns {number}\n\t */\n  function degreeToRadian(value) {\n\n    return value * DEG2RAD;\n\n  }\n\n  var DEG2RAD = Math.PI / 180;\n\n  //\n\n  function findIndex(array, func) {\n\n    for (var i = 0, l = array.length; i < l; i++) {\n\n      if (func(array[i])) return i;\n\n    }\n\n    return -1;\n\n  }\n\n  function append(a, b) {\n\n    for (var i = 0, j = a.length, l = b.length; i < l; i++ , j++) {\n\n      a[j] = b[i];\n\n    }\n\n  }\n\n  function slice(a, b, from, to) {\n\n    for (var i = from, j = 0; i < to; i++ , j++) {\n\n      a[j] = b[i];\n\n    }\n\n    return a;\n\n  }\n\n}\n\nexport default FBXLoader;\n"],
  "mappings": "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",
  "names": ["FBXTree", "curveNode"]
}
